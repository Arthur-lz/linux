# 第一章
* 最大包长度 表征了一个端点单次接收/发送数据的能力，实际上反应的是该端点对应的Buffer 的大小。Buffer 越大，单次可接收/发送的数据包越大，反之亦然。

* 如果USB设备通过集线器和Host通信，主机集线器监视着每个端口的信号电压，当有新设备接入时便可觉察。集线器端口的两根信号线的每一根都有15kΩ的下拉电阻，而每一个设备在D+都有一个1.5kΩ的上拉电阻。当用USB线将PC和设备接通后，设备的上拉电阻使信号线的电位升高，因此被主机集线器检测到。

## 事务
### 分别有IN、OUT和SETUP三大事务，每一种事务都由令牌包、数据包、握手包三个阶段构成

### 事务的三种类型如下(以下按三个阶段来说明一个事务)：

#### 1、 IN事务：

##### 令牌包阶段——主机发送一个PID为IN的输入包给设备，通知设备要往主机发送数据；
##### 数据包阶段——设备根据情况会作出三种反应(要注意：数据包阶段也不总是传送数据的，根据传输情况还会提前进入握手包阶段)。
* 1) 设备端点正常：设备往主机里面发出数据包(DATA0与DATA1交替)；
* 2) 设备正在忙：无法往主机发出数据包就发送NAK无效包，IN事务提前结束，到了下一个IN事务才继续；
* 3) 相应设备端点被禁止：发送错误包STALL包，事务也就提前结束了，总线进入空闲状态。

##### 握手包阶段——主机正确接收到数据之后就会向设备发送ACK包。

#### 2、 OUT事务：
##### 令牌包阶段——主机发送一个PID为OUT的输出包给设备，通知设备要接收数据；
##### 数据包阶段——比较简单，就是主机会往设备送数据，DATA0与DATA1交替
##### 握手包阶段——设备根据情况会作出三种反应
* 1) 设备端点接收正确，设备给主机返回ACK，通知主机可以发送新的数据，如果数据包发生了CRC校验错误，将不返回任何握手信息；
* 2) 设备正在忙，无法给主机返回ACK，就发送NAK无效包，通知主机再次发送数据；
* 3) 相应设备端点被禁止，发送错误包STALL包，事务提前结束，总线直接进入空闲状态。
                                                                                                                                                                                                    
#### 3、SETUT事务：
##### 令牌包阶段——主机发送一个PID为SETUP的输出包给设备，通知设备要接收数据；
##### 数据包阶段——比较简单，就是主机往设备送数据，注意，这里只有一个固定为8个字节的DATA0包，这8个字节的内容就是标准的USB设备请求命令，详见2.4。
##### 握手包阶段——设备接收到主机的命令信息后，返回ACK，此后总线进入空闲状态，并准备下一个传输(在SETUP事务后通常是一个IN或OUT事务构成的传输)。

### USB 采用轮询的广播机制传输数据，所有的传输都由主机发起，任何时刻整个 USB 体系内仅允许一个数据包的传输，即不同物理传输线上看到的数据包都是同一被广播的数据包。   

### 传输由OUT、IN和SETUP事务构成，传输有四种类型，中断传输、批量传输、同步传输、控制传输，其中中断传输和批量传输的结构一样，同步传输有最简单的结构，而控制传输是最重要的也是最复杂的传输。

#### 7域组3包组3事务组4传输
* 7域：SOP,SYNC,Packet,EOP,
* 3包：Token, Data, Handshake
* 3事务：IN, OUT, SETUP
* 4传输：控制、中断、批量、等时传输

#### 控制传输
* 控制传输是一种可靠的双向传输，是最重要也是最复杂的，一次控制传输可分为构成(初始设置阶段、可选数据阶段、状态信息步骤)，每一个阶段可以看成一个传输，也就是说控制传输其实是由三个传输构成的，在USB设备初次接到主机后，主机通过控制传输来交换信息、设备地址和读取设备的描述符，使得主机识别设备，并安装相应的驱动程序，这是每一个USB开发者都要关心的问题。

> 第一阶段：从HOST到Device的SETUP事务传输，这个阶段指定了此次控制传输的请求类型。

> 第二阶段：数据阶段，也有些请求没有数据阶段。

> 第三阶段：状态阶段，通过一次IN/OUT传输表明请求是否成功完成。

> 控制传输通过控制管道在应用软件和Device的控制端点之间进行，控制传输过程中传输的数据是有格式定义的，USB 设备或主机可根据格式定义解析获得的数据含义。其他三种传输类型都没有格式定义。控制传输对于最大包长度有固定的要求。对于高速设备该值为64Byte，对于低速设备该值为8，全速设备可以是8或16或32或64。

> 最大包长度表征了一个端点单次接收/发送数据的能力，实际上反应的是该端点对应Buffer的大小。Buffer越大，单次可接收/发送的数据包越大，反之亦反。当通过一个端点进行数据传输时，若数据的大小超过该端点的最大包长度时，需要将数据分成若干个数据包传输。并保证除最后一个包外，所有的包长度均等于该最大包长度。这也就是说如果一个端点收到/发送了一个长度小于最大包长度的包，即意味着数据传输结束。

> 控制传输在访问总线时也受到一些限制,如高速端点的控制传输不能占用超过 20%的微帧，全速和低速的则不能超过 10%。在一帧内如果有多余的未用时间，并且没有同步和中断传输，可以用来进行控制传输。

> 控制传输(Transaction) 一次控制传输分为三(或两个)个阶段：建立(Setup)、数据(DATA)(可能没有)以及状态(Status)。每个阶段都由一次或多次(数据阶段)事务传输组成(Transaction)。

> 与批量传输相比，在流程上并没有多大区别，区别只在于该事务传输发生的端点不一样、支持的最大包长度不一样、优先级不一样等这样一些对用户来说透明的东西。

> 建立阶段过后，可能会有数据阶段，这个阶段将会通过一次或多次控制传输事务，完成数据的传输。同样也会采用PID翻转的机制。

> 建立阶段，Device 只能返回ACK包，或者不返回任何包。

> 最后是状态阶段，通过一次方向与前一次相反的控制事务传输来表明传输的成功与否。如果成功会返回一个长度为0的数据包，否则返回 NAK或STALL。下图为整个控制传输的示意图：

```
                SETUP           -----> DATA,DATA,....    -----> STATUS
读的控制传输：  SETUP(in)       -----> IN0,IN1,....      -----> STATUS(out)
写的控制传输：  SETUP(out)      -----> OUT0,OUT1,....    -----> STATUS(in)      
```	

> 包是USB总线数据传输的最小单位，不能被打断或干扰，否则会引发错误。若干个数据包组成一次事务传输，一次事务传输也不能打断，属于一次事务传输的几个包必须连续，不能跨帧完成。一次传输由一次到多次事务传输构成，可以跨帧完成     
    
## 枚举

* USB设备连接到HOST时，HOST必须通过默认的控制管道对其进行枚举，完成获得其设备描述、进行地址分配、获得其配置描述、进行配置等操作后方可正常使用。USB设备的即插即用特性即依赖于此。

### 4.1、枚举时USB的状态
#### 当USB设备插上主机时，主机就通过一系列的动作来对设备进行枚举配置(配置是属于枚举的一个态，态表示暂时的状态)，这些态如下：
* 1、接入态(Attached)：设备接入主机后，主机通过检测信号线上的电平变化来发现设备的接入；
* 2、供电态(Powered)：就是给设备供电，分为设备接入时的默认供电值，配置阶段后的供电值(按数据中要求的最大值，可通过编程设置)；
* 3、缺省态(Default)：USB在被配置之前，通过缺省地址0与主机进行通信；
* 4、地址态(Address)：经过了配置，USB设备被复位后，就可以按主机分配给它的唯一地址来与主机通信，这种状态就是地址态；
* 5、配置态(Configured)：通过各种标准的USB请求命令来获取设备的各种信息，并对设备的某些信息进行改变或设置。
* 6、挂起态(Suspended)：总线供电设备在3ms内没有总线操作，即USB总线处于空闲状态的话，该设备就要自动进入挂起状态，在进入挂起状态后，总的电流功耗不超过280uA。

### 4.2、枚举过程
* 1、用户将一个USB设备插入USB端口，主机为端口供电，设备此时处于上电状态。主机检测设备。集线器使用中断通道将事件报告给主机。
* 2、主机发送Get_Port_Status(读端口状态)请求，以获取更多的设备信息。返回的消息告诉主机该设备是什么时候连接的。集线器检测设备是低速运行还是高速运行，并将此信息送给主机，这是对Get_Port_Status>       请求的响应。
* 3、主机发送Set_Port_Feature(写端口状态)请求给集线器，要求它复位端口，请求集线器来重新设置端口。集线器使设备的USB数据线处于重启(RESET)状态至少10ms。
* 4、主机使用Chirp K信号来了解全速设备是否支持高速运行。Chirp是“线性调频脉冲”
* 5、主机发送另一个Get_Port_Status请求，确定设备是否已经从复位状态退出。返回的数据有一位表示设备仍然处于重启状态。当集线器释放了重启状态，设备此时处于缺省状态，且已准备好在零端点通过缺省通道响应主机控制传输。缺省地址为00h，设备能从总线获取高达100mA的电流。
* 6、集线器检测设备速度 
> 集线器通过测定哪根信号线(D+或D-)在空闲时有更高的电压来检测设备是低速设备还是全速设备。全速和高速设备D+有上拉电阻，低速设备D-有上拉电阻。

* 7、获取最大数据包长度
```
        主机向address 0发送Get_Device_Deor(读设备描述符)报文，以取得缺省控制管道所支持的最大数据包长度。并在有限的时间内等待USB设备的响应。该长度包含在设备描述符的bMaxPacketSize0字段中，其地址偏移
量为7，所以这时主机只需读取该描述符的前8个字节。注意，主机一次只能枚举一个USB设备，所以同一时刻只能有一个USB设备使用缺省地址0。
        例：主机向设备发送一个八字节请求：80 06 00 01 00 00 40 00，设备接收到请求后产生一个中断，我们可以通过读中断寄存器知道中断源，并且可以加读最后状态寄存器来确定第一个接到的包是否为一个Setup包
。当控制器处理程序判断出它是一个Get_descriptor请求时，把设备描述符的前16个字节发送到端点0缓冲区中。剩下的2个字节描述符第一次请求时不再发送。
```

* 8、主机分配一个新的地址给设备     
```
主机通过发送一个Set_Address请求来分配一个唯一的地址给设备。设备读取这个请求，返回一个确认，并保存新的地址。从此开始所有通信都使用这个新地址。

        例：当主机收到正确的前16字节描述符后，会给设备分配一个地址，我的PC分配的地址为：0x03（这个要看你的机子当时的USB接口设备数目而定) Set_Address 请求所发送的数据为：00 05 03 00 00 00 00 00，其
中的03就表示主机为设备分配的地址为0x03，在以后的通信里设备就只对0x03地址作出应答。当设备产生一个接收中断后，根据所分配的地址设置设备的地址寄存器相应位。
```
* 9、主机向新地址重新发送Get_Device_Deor命令，此次读取其设备描述符的全部字段，以了解该设备的总体信息，如VID，PID。
```
        例：主机发送设备描述符标准请求Get_descriptor：80 06 00 01 00 00 12 00，此次将要求把18个字节全部发送完。所以主机要分两次来读取。第一次读取16个字节，第二次读取两个字节，最后主机发送0表示发送
完毕的应答。
```
* 10、主机向设备循环发送Get_Device_Configuration命令，要求USB设备回答，以读取全部配置信息。
* 11、主机发送Get_Device_String命令，获得字符集描述（unicode），比如产商、产品描述、型号等等。此时主机将会弹出窗口，展示发现新设备的信息，产商、产品描述、型号等。
```
        根据Device_Deor和Device_Configuration应答，PC判断是否能够提供USB的Driver，一般win2k能提供几大类的设备，如游戏操作杆、存储、打印机、扫描仪等，操作就在后台运行。但是Win98却不可以，所以在此时
将会弹出对话框，索要USB的Driver。
```
* 12、主机分配并加载设备驱动程序，这时就可能作应用中的数据传输了。
* 13、主机发送Set_Configuration(x)(写配置)命令请求为该设备选择一个合适的配置(x代表非0的配置值)。
```
 如果配置成功，USB设备进入“配置”状态，并可以和客户软件进行数据传输。此时，常规的USB完成了其必须
进行的配置和连接工作，至此设备应当可以开始使用。不过，USB协议还提供了一些用户可选的协议，设备如果不应答，也不会出错，但是会影响到系统的功能。
```

* 14、主机为复合设备接口分配驱动程序。如果集线器检测到有过流现象，或者主机要求集线器关闭电源，则USB总线切断设备供电电源。在这种情况下，设备与主机无法通信，但设备处于连接状态。   

   
### USB是串行总线，所以数据是一位一位在数据线上传输的

### USB总线上传输数据是以包为基本单位（但包必须组织成事务才能传输数据）

### 因为usb是主从拓扑结构，所以所有的数据传输都是由主机发起的（唯一的例外是：支持远程唤醒的设备能够主动改变总线状态让集线器感知到设备的唤醒信号，但是这个过程不传递数据，只是改变一下总线的状态）

### 令牌包有四种：IN, OUT, SETUP, SOF
* SOF令牌包格式
```
        |同步域|8位的PID|11位的帧号|5位的CRC5校验|EOP|
```

### 全速设备每1m发一帧
### 高速设备每125us发一帧，即1ms发8个微帧，这8个微帧的帧号相同, 即相同的SOF
        
### OUT, IN, SETUP三种包的令牌格式相同，如下:
```
        |同步域|8位的PID|7位地址|4位端点号|5位的CRC5校验|EOP|
```

### OUT令牌包发送之后，不管设备是否有足够的空间接收数据，都会在OUT令牌包之后发送一个数据包, 如果设备没有空间接收数据，则设备会回一个NAK
> 这样的话就是浪费了总线带宽, 在usb2.0后增加了PING令牌包机制，主机先用PING来试试设备是否足够空间来接收数据，而不是事先将数据发送出去

### 数据包有四种：DATA0, DATA1, DATA2, MDATA，它们的格式都相同，usb1.1只有前两种
```
        |同步域|8位的PID|字节0|字节1|...|字节N|16位的CRC16校验|EOP|
```

> 使用这么些个数据包类型是为了在握手包出错时纠错

> 主机和设备都会维护自己的一个数据包切换机制：当数据包成功发送或接收时，数据包类型切换;

> 当检测到对方所使用的数据包类型不对时，USB系统认为发生了一个错误，则它会试图从错误中恢复

> 数据包类型不匹配主要发生在握手包被损坏的情形

### 握手包，用来表示一个传输是否被对方确认.它的结构如下
```
        |同步域|8位的PID|EOP|
```
* 握手包有ACK, NAK, STALL和NYET四种
> ACK表示正确接收数据，并且有足够的空间容纳数据。主机和设备都可以使用ACK来确认数据。
> NAK, STALL, NYET只有设备可以使用，而主机不可以使用

> NAK, 表示没有数据需要返回，或者数据正确接收但没有足够的空间容纳它们。

```
        当主机收到NAK时，知道设备还没有准备好，主机会以后合适的时机重试传输
        主机收到NAK不代表出错，只是说明暂时设备没有数据输出或暂时没有能力接收数据。
        当USB主机或设备检测到数据出错时（如CRC校验错、PID校验错、位填充错等），将什么都不返回，这时等待接收握手包的一方就会收不到握手包而等待超时.
```        
> STALL，表示设备无法执行这个请求，或者端点已经被挂起，它表示一种错误的状态. 设备返回STALL状态后，需要主机干预才能解除设备的这种STALL状态

> NYET，在usb2.0上用，它表示设备本次成功接收了数据，但没有足够的空间来接收下一次的数据

### 特殊包, usb2.0及之前的版本有四种：PRE, SPLIT, PING, ERR，前三个是令牌包，ERR是握手包    
* PING令牌包与OUT令牌包格式相同，但PING令牌包之后不发送数据，而是等待设备返回ACK或者NAK, 以判断设备能够传送数据                                                                               
> usb1.1中无PING令牌包

> PING令牌包只被使用在usb2.0及以上的批量传输和控制传输的输出事务中

* SPLIT令牌包通知集线器将数据包分成全速或低速数据包发送给其下面的端口    

### 传输相关的内容大部分工作由usb芯片负责完成，如：CRC校验、位填充、PID识别、数据包切换、握手等协议的处理   
```
        当usb芯片正确接收到数据时，如果有空间保存，则它将数据保存并返回ACK, 同时设置一个标志表示已经正确接收了数据。如果没有空间保存则会返回NAK
        当usb芯片收到输入数据请求时，如果有数据需要发送，则发送数据，并等待接收ACK。只有当数据成功发送出去后（usb芯片收到ACK），它才设置标志，表示数据已经成功发送；
        如果无数据需要发送，则芯片返回NAK
```        

### usb事务，由两到三个包组成：令牌包、数据包和握手包       
* 1. 令牌包，用来启动一个事务，总是由主机发送
* 2. 数据包，可以由主机到设备，也可以由设备到主机，包中数据的方向由令牌包来指定
* 3. 握手包，握手包的发送者通常是由数据接收者发送，当数据接收正确后，发送握手包。

### usb协议规定有四种事务：批量、中断、等时、控制事务
* 1. 批量、中断、等时传输每传输一次数据都是一个事务
* 2. 控制传输包括三个过程：建立过程、状态过程分别是一个事务，数据过程可能有多个事务


> USB协议规定不允许主机使用NAK来向设备说主机自己没有空间来接收数据，因为如果主机要这么做的话就搞笑了，主机又要发IN请求给设备说要从设备读数据，设备把数据返回给主机时，主机又说它没有空间来存数据，这就显得主机是“U+SB”

#### 批量传输
* 1. 批量传输由批量事务来传输数据。批量事务由三个阶段组成：令牌包阶段、数据包阶段、状态包阶段
> 批量传输中没有规定数据包的结构和意义，具体的结构由设备自己定义

* 2. 一次正确的批量输入事务
```
        主机发送令牌包：|SYNC|IN PID|7位地址|4位端点号|5位CRC5校验|EOP|
        设备返回数据包：|SYNC|DATA PID|字节0|字节1|...|字节N|16位CRC16校验|EOP|
        主机发送状态包：|SYNC|ACK PID|EOP|
```

* 3. 一次正确的批量输出事务
```
        主机发送令牌包：|SYNC|OUT PID|7位地址|4位端点号|5位CRC5校验|EOP|
        主机发送数据包：|SYNC|DATA PID|字节0|字节1|...|字节N|16位CRC16校验|EOP|
        设备返回状态包：|SYNC|ACK PID|EOP|
```

#### 中断传输
* 这是一种保证查询频率的传输，在中断端点中要明确给出查询的时间间隔，主机会保证在小于这个时间间隔的范围安排一次传输
* 中断传输通常用在数据量不大，但对时间要求严格的设备中, 如鼠标、键盘
* 中断传输也可以用来检测某种状态，当条件满足后启用批量传输来传输大批量数据

#### 等时传输
* 要保证传输不能停顿

#### 控制传输
* 1. 数据包只能是DATA0
* 2. 设备只能使用ACK应答，就是说设备必须要接收主机发来的数据包, 除非出错不应答，如果应答就必须是ACK，不能是其他                                                                               
* 3. 数据过程中，第一个数据包必须是DATA1；此过程中，可以有多个数据事务，但所有的数据事务方向必须相同；

### 端点0是每个USB设备都必须具备的默认控制端点，它一上电就存在并可用     


# 第二章 硬件系统设计
## usb接口芯片
### PDIUSBD12芯片
* 这是一块荷兰Philips半导体公司的USB接口芯片
* 它支持usb2.0, 软连接，数据流提示灯功能 
* 它使用8位并行的数据口与mcu连接
> 数字引脚兼容5v电压

> 内置3.3v稳压器

> 内置锁相环

> 外部使用6MHz晶振作为时钟源

> 除了0端点，它还有两个额外端点

> 端点0,1支持最大包长16字节

> 端点2普通模式下支持最大包长64字节，端点2还支持等时传输模式，单向时支持最大包长128字节，双向时支持最大包长64字节 

* 要正确使用这个usb芯片首先要阅读它的数据手册datasheet
> datasheet由芯片厂商提供

# 第三章 USB鼠标的实现
## 3.2 USB的断开与连接
### D12的设置模式命令
* set Mode命令代码是0xF3, 它后面跟两字节数据
> 第一个字节是配置字节

```
0位：保留，并置0
1位：无懒时钟模式
2位：时钟运行
3位：中断模式, 该位置1表示所有的错误和NAK都将产生中断请求；该位置0时则只有当传输正确时（对于输出端点，正确接收到数据；对于输入端点，正确发送数据）才产生中断；该位在usb总线复位进不变
4位：软连接控制
5位：保留，置0
6、7位：端点配置
```

> 第二字节是时钟分频系数

```
0~3位：时钟分频系数。假设该值为N，那么CLKOUT端的频率就是48MHz除以N+1; USB总线复位不会影响该值
4、5位：保留，置0
6位：必须置1
7位：仅在SOF时产生中断。该位置1时只有当帧起始时才产生中断信号 
```


## 3.3 usb中断处理
* 当D12芯片完成一个操作后，就会产生中断请求信号, 以通知cpu来进行相关处理
* 导致中断发生的事件有：
> usb总线复位

> D12进入挂起状态

> 成功接收到数据

> 发送完数据

* 具体是什么类型的中断可以通过判断D12的中断寄存器来明确
```
1. 读取中断寄存器的命令为：
2. 发送该命令后可以读取到两字节数据，第一字节中的内容是端点和总线状态的中断，第二字节的内容只有一位有效，且与DMA相关
   第一字节的详细结构如下：
   0: 端点0输出
   1: 端点0输入
   2: 端点1输出
   3: 端点1输入
   4：端点2输出
   5：端点2输入
   6：总线复位 
   7：挂起状态改变
   如果第一字节中某位的值为1，则表示该中断源发出了中断请求
   通过判断该寄存器每一位的值，即可知出现了哪一种中断
   

```
## 3.4 读取从主机发送到端点0的数据
* 读取D12的数据缓存区，使用D12的读缓冲区命令，它的代码是0xF0
* D12有很多端点，如何决定读的是哪一个端点的缓冲区呢？这需要用到D12的选择端点命令
* 在端点0输出中断处理函数中调用读取端点缓冲的函数，以读取主机发送给D12的数据
> 这里所说的函数，是写到mcu上的，mcu用来通过串口与主机通信，将D12与主机间的数据最终以串口来显示在pc上，方便查看D12与主机是如何通信的

### 为什么要清中断？
* 如果在读了数据后，不清除中断就会一直提示有中断发生
#### 如何清除中断？
* 清除端点中断标志位要使用“读最后传输状态”命令，该命令代码为0x40~0x45, 分别对应着三个端点的输入和输出
> 发送完“读最后传输状态”命令后，可以读1字节数据，数据的内容为该端点传输的最后状态，详细的结构如下

```
0: 数据接收或发送成功, 值为1表示成功
1, 2, 3, 4: 出错代码
5: 建立包， 值为1表示收到的是setup过程的数据包，在控制传输中，这一位很重要，因为setup包是令牌包，即控制传输的第一个包
6: DATA0或DATA1包, 值为0表示收到的是DATA0数据包，值为1表示收到的是DATA1数据包
7：前一次状态未读, 值为1表示前一次状态没有读取
```

### 为什么要清除数据缓冲区？
#### 如果在读取数据后，不清除数据缓冲区，就不能再接收新的数据
* 清数据缓冲的命令clear buffer代码是0xF2
> 如果一个端点在接收数据后没有使用clear buffer命令，对于以后发往该端点的数据包将使用NAK来应答，但对于建立过程的数据包除外，设备必须接收它

> clear buffer命令针对于输出端点

> validate buffer命令针对于输入端点

### 记录主机与usb设备通信的实验
#### 实验内容
* 1. 编写keil程序并写入开发板中mcu芯片
* 2. 实验输出
```
断开usb连接
usb连接
usb总线挂起
usb总线复位
usb总线挂起
usb总线复位
usb端点0输出中断
读端点0缓冲区8字节
0x80 0x06 0x00 0x01 0x00 0x00 0x40 0x00
usb总线复位
usb端点0输出中断
读端点0缓冲区8字节
0x80 0x06 0x00 0x01 0x00 0x00 0x40 0x00
usb总线复位
usb端点0输出中断
读端点0缓冲区8字节
0x80 0x06 0x00 0x01 0x00 0x00 0x40 0x00
usb总线挂起
```
> 这8字节的数据是由主机发给usb设备的，这8字节代表的命令是主机想要从usb设备获取设备描述符, 这是一个标准的usb请求

## 3.5 USB标准请求
### usb协议定义了一个8字节的标准设备请求，主要用在设备的枚举过程中
* 这8字节数据是在控制传输的建立过程通过默认控制端点0发出的

* 这8字节的数据包中包含了：
> 1. 数据传输过程所需要的数据传输方向                                                                                                                                                               

> 2. 数据类型

> 3. 数据长度

* 正是这8字节标准请求的存在，USB协议规定：端点0的数据包最大长度最小是8字节
> 也就是说任何一个usb设备必须能够接收8字节的标准请求

### 3.5.1 usb标准请求的结构
* 前面一节的实验中讲的8字节的数据包，这8字节的具体含义如从确认？usb协议定义
|偏移量/字节|域|大小/字节|取值|描述|
|:-|:-|:-|:-|:-|
|0|bmRequestType|1|位图|请求的特性：D7: 数据传输方向, 0是主机到设备, 1是设备到主机;D6~D5: 请求类型, 0=标准, 1=类，2=厂商, 3=保留;D4~D0: 0=设备, 1=接口, 2=端点, 3=其他, 4~31=保留;|
|1|bRequest|1|数值|请求代码|
|2|wValue|2|数值|该域的意义由具体的请求决定|
|4|wIndex|2|索引或偏移量|该域的意义由具体的请求决定|
|6|wLength|2|字节数|数据过程（如果有）所需要传输的字节数|

> 注：本节只介绍标准请求，即D6~D5=00

* usb协议定义了11个标准请求, 如下所示
|bRequest|Value|
|:-|:-|
|GET_STATUS|0|
|CLEAR_FEATURE|1|
|SET_FEATURE|3|
|SET_ADDRESS|5|
|GET_DESCRIPTOR|6|
|SET_DESCRIPTOR|7|
|GET_CONFIGURATION|8|
|SET_CONFIGURATION|9|
|GET_INTERFACE|10|
|SET_INTERFACE|11|
|SYNCH_FRAME|12|

> 不同的请求，对于其接收者、wValue、wIndex各字节的意义是不同的

* 下面是各个标准请求以及数据过程需要传输的数据
> 关于此表有几点先说一下
```
1. 第1列有多个值，主要是最低位不同，即表示接收者不同
2. 有的请求只能发送到设备
3. 有的请求可以发送到设备，也可以发送到接口，也可以发送到端点
```

|bmRequestType|bRequest|wValue|wIndex|wLength|数据过程|
|:-|:-|:-|:-|:-|:-|
|00000000B,00000001B,00000010B|CLEAR_FEATURE|特性选择|0, 接口号, 端点号|0|没有|
|10000000B|GET_CONFIGURATION|0|0|1|配置值|
|10000000B|GET_DESCRIPTOR|描述符类型和索引|0或者语言ID|描述符的长度|描述符|
|10000001B|GET_INTERFACE|0|接口号|1|备用接口号|
|10000000B,10000001B, 10000010B|GET_STATUS|0|0,接口号,端点号|,2,|设备、接口或端点状态|
|00000000B|SET_ADDRESS|设备地址|0|0|没有|
|00000000B|SET_CONFIGURATION|配置值|0|0|没有|
|00000000B|SET_DESCRIPTOR|描述符类型和索引|0或者语言ID|描述符的长度|描述符|
|00000000B,00000001B,00000010B|SET_FEATURE|特性选择|0, 接口号, 端点号|0|没有|
|00000001B|SET_INTERFACE|备用接口号|接口号|0|没有|
|10000010B|SYNCH_FRAME|0|端点号|2|帧号|

### 3.5.2 GET_DESCRIPTOR请求
> 这是在枚举过程中用的最多的请求

> 主机通过发送获取描述符请求读取设备的各种描述符, 从而可以知道设备是什么类型、端点情况等重要信息

> 获取描述符的接收者只能是设备

> 从bmRequestType的值10000000B也可以确认，其第7位值为1，表示数据传输方向是由设备到主机

> wValue域的第一字节表示的是索引号，它表示同一种描述符中具体是哪一种描述符

> wValue域的第二字节是描述符类型编号

```

|编号|描述符类型|
|:-|:-|
|1|设备描述符|
|2|配置描述符|
|3|字符串描述符|
|4|接口描述符|
|5|端点描述符|
> wIndex只在获取字符串描述符时有用，用来指定不同的语言ID号;获取其他类型的描述符时其值为0

> wLength域为请求设备返回数据的字节数，设备实际返回的字节数可以比这个域设置的字节数少

> 设备在收到主机发送的获取描述符请求后，应该按照所请求的描述符类型编号，在数据过程中返回相应的描述符

> 对于Full speed, low speed设备获取描述符请求只有三种：获取设备描述符、获取配置描述符、获取字符串描述符, 其他的接口描述符、端点描述符必须跟随获取配置描述请求末尾一并返回，不能单发请求

> 在usb协议中规定wValue, wIndex, wLength都是两个字节的，它们都是小端字节序(底字节在前，高字节在后)

```

### 3.5.3 SET_ADDRESS请求
* 这是主机请求设备使用指定地址的请求，指定的地址在8字节数据的wValue中指定
* 每一个连接在主控制器上的usb设备都必须具有一个唯一的设备地址, 这样主机才能区分不同的usb设备
* 当设备复位后都使用默认的地址0
* 主机从地址为0的设备获取设备描述符，一旦收到第一次设备描述符后，主机就会发送设置设备地址的请求，以尽量减少设备占用公用设备地址0的时间
* 设置地址请求是没有数据过程的，因而wLengt = 0, wIndex也用不着也为0
* 当设备收到设置地址请求后，就直接进入状态过程，等待主机读取0长度的状态数据包，主机成功读取到状态数据包后，设备将启用新地址
> 这以后主机与设备之间的通信全部使用新的地址完成

### 3.5.4 SET_CONFIGURATION请求
* wValue的值是配置的值，该值与某个配置描述符编号相等时，表示选中该配置
> 该值通常为1, 因为大多数usb设备只有一个配置

## 3.6 设备描述符的实现
* 已知每个设备有且仅有一个设备描述符，它的结构在usb协议中有详细的定义
* 设备描述符的结构

|偏移量/字节|域|大小/字节|说明|
|:-|:-|:-|:-|
|0|bLength|1|该描述符的长度(18字节)|
|1|bDescriptType|1|描述符类型|
|2|bcdUSB|2|本设备使用的USB协议版本|
|4|bDeviceClass|1|类代码|
|5|bDeviceSubClass|1|子类代码|
|6|bDeviceProtocol|1|设备所使用的协议|
|7|bMaxPackageSize0|1|端点0最大包长|
|8|idVender|2|厂商ID|
|10|idProduct|2|产品ID|
|12|bcdDevice|2|设备版本号|
|14|iManufacturer|1|描述厂商的字符串索引|
|15|iProduct|1|描述产品的字符串索引|                                                                                                                                                                
|16|iSerialNumber|1|产品序列号字符串索引|
|17|iNumConfigurations|1|可能的配置个数|
> bcdUSB

```
1. 它的值是以BCD码来表示的
以设备的协议为2.0, 1.1为例说明一下
USB2.0协议就是0x0200
USB1.1协议就是0x0110
前面说过USB协议中使用的是小端字节序，所以实际数据在传输时，是低字节在先的，也就是说：
USB2.0协议的bcdUSB拆成两个字节就是0x00和0x20
USB1.1协议的bcdUSB拆成两个字节就是0x10和0x01

```










































