## 体系

### 机器语言01、汇编语言、C语言

#### 扫盲rsp, edi, eax
* 这些是CPU中寄存器的名字
##### 指令寄存器
* 它们主要用于访问堆栈内的存储单元，并且规定：

（1）BP为基指针(BasePointer)寄存器，用它可直接存取堆栈中的数据；
（2）SP为堆栈指针(StackPointer)寄存器，用它只可访问栈顶。
* 寄存器RBP、RSP和EBP、ESP和BP、SP称分别为64位、32位、16位指针寄存器(PointerRegister)

##### 变址寄存器
* 它们可作一般的存储器指针使用。在字符串操作指令的执行过程中，对它们有特定的要求，而且还具有特殊的功能。
* 寄存器RSI、RDI和ESI、EDI和SI、DI分别称为64位、32位、16位变址寄存器(Index Register)。

##### 数据寄存器
* 主要用来保存操作数和运算结果等信息，从而节省读取操作数所需占用总线和访问存储器的时间。
* RAX、RBX、RCX、RDX和EAX、EBX、ECX、EDX以及AX、BX、CX、DX分别称为64位、32位、16位数据寄存器(通用寄存器)。

##### 寄存器基本概念 
* 在中央处理器的控制部件中，包含的寄存器有指令寄存器(IR)和程序计数器(PC)。
* 在中央处理器的算术及逻辑部件中，包含的寄存器有累加器(ACC)。

#### 汇编
* 汇编的编译解释与具体的体系结构相关，如，在x86平台上，CPU是Intel的，那么需要用到Intel开发人员手册，里面有关于汇编助记符的定义，
  如subq, addq, movl等

> 为什么与体系结构相关? 首先要明白，汇编器的作用是将汇编程序翻译成机器码，机器码与具体的CPU相关，只有正确的芯片才可以识别出。

### DMA
   外设（如磁盘）与主存建立映射，CPU告诉DMA需要传多少数据，只有当将所需数据全部由外设传递到主存后才通知CPU，而不是每读一部分数据（如一个字节）就通知一下CPU							 

### ulimit -s 查看linux进程默认栈大小, 结果的单位是kB;
   也可以用ulimit -a查询所有资源限制，结果中包含了单位   

### 使用int32_t等数据类型宏定义来支持程序的可移植性   
    这样就不会因为从32位机切到64位机时出现数据类型对应到不同的位长度问题

## 第1章
### 1.1 信息就是位 + 上下文
* 系统中所有的信息都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据时的上下文。    
* C语言是设计用来实现Unix操作系统的.

### 1.2 程序被其他程序翻译成不同格式
* 编译系统
hello.c->预处理->hello.i(修改了的源程序，还是文本) 
	     ->编译器(cc)->hello.s（汇编程序，还是文本）
	         ->汇编器(as)->hello.o （可重定位的目标程序，已经变成二进制文件）
		     ->链接器(ld)->hello.out（可执行的目标程序，二进制文件）

* 预处理，根据源文件中以字符#开头的命令修改原始的C程序。

* 编译器，将.i文件翻译成文件文件.s，它是一个包含汇编语言的程序。

* 汇编器，将.s文件翻译成机器语言指令，并把结果保存在二进制.o文件中。

* 链接器，将源程序中依赖的目标文件合并到可执行目标文件。

### 1.3 了解编译系统如何工作是大有益处的
### 1.4 处理器读并解释存储在内存中的指令
#### 1.4.1 系统的硬件组成 
#### 1.4.2 运行hello程序
* 见目录deepincomputerlab/code/intro/目录中的几个图片说明了hello从终端输入到运行结束全过程.
### 1.5 高速缓存至关重要
* 解决CPU与主存之间速度差过大（100倍左右）而引入高缓。
### 1.6 存储设备形成层次结构
* 见目录deepincomputerlab中的png
### 1.7 操作系统管理硬件
* 操作系统有两个功能
> 防止硬件被失控的应用程序滥用

> 向应用程序提供简单一致的机制来控制复杂又不相同的低层硬件设备

* 操作系统通过三个抽象来实现上面的两个功能，即虚拟内存、进程、文件
> 文件是对I/O设备的抽象

> 虚拟内存是对主存和磁盘I/O设备的抽象

> 进程是对CPU、主存、I/O设备的抽象

#### 1.7.1 进程
* 在一个系统上可以同时运行多个进程, 
* 并发运行，指一个进程的指令和另一个进程的指令是交错执行的, 这是通过处理器在进程间切换实现的, 这种机制称为上下文切换。
* 操作系统会保存进程运行所需的所有状态信息, 这种状态就是上下文，包括：PC(程序计数器)、寄存器中的值，主存的内容等。
* 在任何一个时刻，单核处理器只能运行一个进程的代码
* 当操作系统决定把控制权从当前进程转移到某个新进程时，就会进行上下文切换。即，保存当前进程上下文，恢复新进程上下文，然后将控制权转移到新进程，新进程就会从它上次停止的地方开始执行。

* 内核不是一个独立的进程，它是什么呢？内核是操作系统管理全部进程所需要的代码和数据结构的集合。

#### 1.7.2 线程
* 线程运行在进程上下文
* 线程间共享数据更方便简单
* 多线程可提高性能，当然你的应用程序必须要使用多线程才可以

#### 1.7.3 虚拟内存 
* 它提供了一种假象，即，每个进程都是独占的使用内存
* 每个进程看到的内存都是相同的, 称为虚拟地址空间

#### 1.7.4 文件 
* 文件就是字节序列

### 1.8 系统之间利用网络来通信 
### 1.9 重要主题
#### 1.9.1 Amdahl 定律(阿姆达尔定律)
* 用于分析计算系统性能的定律
* S = Told / Tnew
* S = 1/((1 - a) + a/k)

#### 1.9.2 并发和并行
* 线程级并发
> 多核处理器结构，L1，L2在每一个核的内部，L3在核的外部CPU内部是所有核共享的一块高速缓存

> 多核处理器可以从两方面提高系统性能，1是减少使用并发，2是提高应用程序速度（当然应用程序必须以多线程方式编写，这些线程可以并行执行）

> 线程级并发我的理解与进程并发原理相同，比如，一个线程必须要等到数据加载到L1高速缓存中，那么此时CPU就可以去执行另外一个线程。

* 指令级并行
> 指令流水线, 将一条指令拆分成不同的步骤，将处理器的硬件组织成一系统阶段，每个阶段执行一个步骤，这些阶段并行的执行，用来处理不同指令的不同部分。

* 单指令多数据并行(SIMD) 

#### 1.9.3 计算机系统中抽象的重要性 
* 指令集架构是对实际处理器硬件的抽象，这样机器代码表现得好像运行在一个一次只执行一条指令的处理器上一样。

### 1.10 小结
* 计算机系统是硬件和系统软件组成的，它们共同协作让应用程序可以运行。

## 第二章 信息的表示和处理 
* 学习目标？
> 数据类型是如何表示的?

> 硬件是如何实现的？如，CPU是如何实现的？这些硬件是如何被用来执行指令的？

> 程序是如何表示的? 如何执行的?

* 二进制数－－－数字革命的基础
> 在构造存储和处理信息的机器时，二进制工作得更好。二进制可以很容易被表示，如：电平的高低、磁的两极、打孔机的孔。

* 程序员需要对计算机运算与人类熟悉的整数和实数运算之间的关系有清晰的理解

* C的几个不同版本 
> GNU 89, GCC命令行无配置选项时，或-std=gnu89时，使用GNU 89版本的C语言进行编译

> ANSI C, ISO C90, GCC命令行选项使用-ansi, 或 -std=c89时，使用

> ISO C99, GCC命令行使用选项 -std=c99

> ISO C11, GCC命令行使用选项 -std=c11

### 2.1 信息存储
* C语言中，一个指针的值，无论它指向什么数据结构（整数、结构或某个其他程序对象），它都是某个存储块第一个字节的虚拟地址。

* 大概理解了，为什么为有虚拟地址空间这个概念，因为要统一程序自身的差异，这样编译器和运行时系统才可以知道如何用内存来存放不同的程序对象。

* C编译器维护指针类型，但它编译出来的机器指令中没有数据类型相关信息。其实时这样，数据类型是告诉程序需要从指针所指的地址处读多长的数据，
  如int *p; int表示指针p所指向的地址处有四个字节的数据是有效的，在p++时，指针p会移动四个字节；而前面说的四个字节是由数据类型int而得到的。

#### 2.1.1 十六进制表示法  
* 10进制数转16进进制方法
> 举例说明：10进制数188转成16进制
  188 = 11 * 16 + 12   ---> C
  11 = 0 * 16 + 11     ---> B
  所以，十进制数188对应的十六进制数为0xBC
> 这里需要注意的是第一，下次等号左面的数是上一个等式中乘16的那个数
                  第二，最后一个等式的余数是十六进制数的最高位

* 16进制转10进制方法
> 举例说明: 16进制数0x3C转换成10进制数x
  x = 3 * (16 * 1) + 12 * (16 * 0) = 60
                |               |
            16的一次方       16的0次方
                
* 16进制转2进制方法
> 举例说明: 16进制数0x12转换成2进制数x
  x = 0001 0010
       |    |
       1    2

#### 2.1.2 字数据大小
* 每台计算机都有一个字长，指明指针数据的标称大小。虚拟地址是以这样一个字来编码的。

|||||
|:-|:-|:-|:-|
|C声明||字节数|字节数|
|有符号|无符号|32位|64位|
|char|unsigned char|1|1|
|short|unsigned short|2|2|
|int|unsigned|4|4|
|long|unsigned long|4|8|
|int32_t|uint32_t|4|4|
|int64_t|uint64_t|8|8|
|char*||4|8|
|float||4|4|
|double||8|8|














