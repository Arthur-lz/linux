## 体系

### 机器语言01、汇编语言、C语言

#### 扫盲rsp, edi, eax
* 这些是CPU中寄存器的名字
##### 指令寄存器
* 它们主要用于访问堆栈内的存储单元，并且规定：

（1）BP为基指针(BasePointer)寄存器，用它可直接存取堆栈中的数据；
（2）SP为堆栈指针(StackPointer)寄存器，用它只可访问栈顶。
* 寄存器RBP、RSP和EBP、ESP和BP、SP称分别为64位、32位、16位指针寄存器(PointerRegister)

##### 变址寄存器
* 它们可作一般的存储器指针使用。在字符串操作指令的执行过程中，对它们有特定的要求，而且还具有特殊的功能。
* 寄存器RSI、RDI和ESI、EDI和SI、DI分别称为64位、32位、16位变址寄存器(Index Register)。

##### 数据寄存器
* 主要用来保存操作数和运算结果等信息，从而节省读取操作数所需占用总线和访问存储器的时间。
* RAX、RBX、RCX、RDX和EAX、EBX、ECX、EDX以及AX、BX、CX、DX分别称为64位、32位、16位数据寄存器(通用寄存器)。

##### 寄存器基本概念 
* 在中央处理器的控制部件中，包含的寄存器有指令寄存器(IR)和程序计数器(PC)。
* 在中央处理器的算术及逻辑部件中，包含的寄存器有累加器(ACC)。

#### 汇编
* 汇编的编译解释与具体的体系结构相关，如，在x86平台上，CPU是Intel的，那么需要用到Intel开发人员手册，里面有关于汇编助记符的定义，
  如subq, addq, movl等

> 为什么与体系结构相关? 首先要明白，汇编器的作用是将汇编程序翻译成机器码，机器码与具体的CPU相关，只有正确的芯片才可以识别出。

### DMA
   外设（如磁盘）与主存建立映射，CPU告诉DMA需要传多少数据，只有当将所需数据全部由外设传递到主存后才通知CPU，而不是每读一部分数据（如一个字节）就通知一下CPU							 

### ulimit -s 查看linux进程默认栈大小, 结果的单位是kB;
   也可以用ulimit -a查询所有资源限制，结果中包含了单位   

### 使用int32_t等数据类型宏定义来支持程序的可移植性   
    这样就不会因为从32位机切到64位机时出现数据类型对应到不同的位长度问题

## 第1章
### 1.1 信息就是位 + 上下文件
* 系统中所有的信息都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据时的上下文。    
* C语言是设计用来实现Unix操作系统的.

### 1.2 程序被其他程序翻译成不同格式
* 编译系统
hello.c->预处理->hello.i(修改了的源程序，还是文本) 
	     ->编译器(cc)->hello.s（汇编程序，还是文本）
	         ->汇编器(as)->hello.o （可重定位的目标程序，已经变成二进制文件）
		     ->链接器(ld)->hello.out（可执行的目标程序，二进制文件）

* 预处理，根据源文件中以字符#开头的命令修改原始的C程序。

* 编译器，将.i文件翻译成文件文件.s，它是一个包含汇编语言的程序。

* 汇编器，将.s文件翻译成机器语言指令，并把结果保存在二进制.o文件中。

* 链接器，将源程序中依赖的目标文件合并到可执行目标文件。

### 1.3 了解编译系统如何工作是大有益处的
### 1.4 处理器读并解释存储在内存中的指令
#### 1.4.1 系统的硬件组成 
#### 1.4.2 运行hello程序
* 见目录deepincomputerlab/code/intro/目录中的几个图片说明了hello从终端输入到运行结束全过程.
### 1.5 高速缓存至关重要
* 解决CPU与主存之间速度差过大（100倍左右）而引入高缓。
### 1.6 存储设备形成层次结构
* 
