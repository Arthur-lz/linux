## 体系

### 机器语言01、汇编语言、C语言

#### 扫盲rsp, edi, eax
* 这些是CPU中寄存器的名字
##### 指令寄存器
* 它们主要用于访问堆栈内的存储单元，并且规定：

（1）BP为基指针(BasePointer)寄存器，用它可直接存取堆栈中的数据；
（2）SP为堆栈指针(StackPointer)寄存器，用它只可访问栈顶。
* 寄存器RBP、RSP和EBP、ESP和BP、SP称分别为64位、32位、16位指针寄存器(PointerRegister)

##### 变址寄存器
* 它们可作一般的存储器指针使用。在字符串操作指令的执行过程中，对它们有特定的要求，而且还具有特殊的功能。
* 寄存器RSI、RDI和ESI、EDI和SI、DI分别称为64位、32位、16位变址寄存器(Index Register)。

##### 数据寄存器
* 主要用来保存操作数和运算结果等信息，从而节省读取操作数所需占用总线和访问存储器的时间。
* RAX、RBX、RCX、RDX和EAX、EBX、ECX、EDX以及AX、BX、CX、DX分别称为64位、32位、16位数据寄存器(通用寄存器)。

##### 寄存器基本概念 
* 在中央处理器的控制部件中，包含的寄存器有指令寄存器(IR)和程序计数器(PC)。
* 在中央处理器的算术及逻辑部件中，包含的寄存器有累加器(ACC)。

#### 汇编
* 汇编的编译解释与具体的体系结构相关，如，在x86平台上，CPU是Intel的，那么需要用到Intel开发人员手册，里面有关于汇编助记符的定义，
  如subq, addq, movl等

> 为什么与体系结构相关? 首先要明白，汇编器的作用是将汇编程序翻译成机器码，机器码与具体的CPU相关，只有正确的芯片才可以识别出。

### DMA
   外设（如磁盘）与主存建立映射，CPU告诉DMA需要传多少数据，只有当将所需数据全部由外设传递到主存后才通知CPU，而不是每读一部分数据（如一个字节）就通知一下CPU							 

### ulimit -s 查看linux进程默认栈大小, 结果的单位是kB;
   也可以用ulimit -a查询所有资源限制，结果中包含了单位   

### 使用int32_t等数据类型宏定义来支持程序的可移植性   
    这样就不会因为从32位机切到64位机时出现数据类型对应到不同的位长度问题

## 第1章
### 1.1 信息就是位 + 上下文
* 系统中所有的信息都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据时的上下文。    
* C语言是设计用来实现Unix操作系统的.

### 1.2 程序被其他程序翻译成不同格式
* 编译系统
hello.c->预处理->hello.i(修改了的源程序，还是文本) 
	     ->编译器(cc)->hello.s（汇编程序，还是文本）
	         ->汇编器(as)->hello.o （可重定位的目标程序，已经变成二进制文件）
		     ->链接器(ld)->hello.out（可执行的目标程序，二进制文件）

* 预处理，根据源文件中以字符#开头的命令修改原始的C程序。

* 编译器，将.i文件翻译成文件文件.s，它是一个包含汇编语言的程序。

* 汇编器，将.s文件翻译成机器语言指令，并把结果保存在二进制.o文件中。

* 链接器，将源程序中依赖的目标文件合并到可执行目标文件。

### 1.3 了解编译系统如何工作是大有益处的
### 1.4 处理器读并解释存储在内存中的指令
#### 1.4.1 系统的硬件组成 
#### 1.4.2 运行hello程序
* 见目录deepincomputerlab/code/intro/目录中的几个图片说明了hello从终端输入到运行结束全过程.
### 1.5 高速缓存至关重要
* 解决CPU与主存之间速度差过大（100倍左右）而引入高缓。
### 1.6 存储设备形成层次结构
* 见目录deepincomputerlab中的png
### 1.7 操作系统管理硬件
* 操作系统有两个功能
> 防止硬件被失控的应用程序滥用

> 向应用程序提供简单一致的机制来控制复杂又不相同的低层硬件设备

* 操作系统通过三个抽象来实现上面的两个功能，即虚拟内存、进程、文件
> 文件是对I/O设备的抽象

> 虚拟内存是对主存和磁盘I/O设备的抽象

> 进程是对CPU、主存、I/O设备的抽象

#### 1.7.1 进程
* 在一个系统上可以同时运行多个进程, 
* 并发运行，指一个进程的指令和另一个进程的指令是交错执行的, 这是通过处理器在进程间切换实现的, 这种机制称为上下文切换。
* 操作系统会保存进程运行所需的所有状态信息, 这种状态就是上下文，包括：PC(程序计数器)、寄存器中的值，主存的内容等。
* 在任何一个时刻，单核处理器只能运行一个进程的代码
* 当操作系统决定把控制权从当前进程转移到某个新进程时，就会进行上下文切换。即，保存当前进程上下文，恢复新进程上下文，然后将控制权转移到新进程，新进程就会从它上次停止的地方开始执行。

* 内核不是一个独立的进程，它是什么呢？内核是操作系统管理全部进程所需要的代码和数据结构的集合。

#### 1.7.2 线程
* 线程运行在进程上下文
* 线程间共享数据更方便简单
* 多线程可提高性能，当然你的应用程序必须要使用多线程才可以

#### 1.7.3 虚拟内存 
* 它提供了一种假象，即，每个进程都是独占的使用内存
* 每个进程看到的内存都是相同的, 称为虚拟地址空间

#### 1.7.4 文件 
* 文件就是字节序列

### 1.8 系统之间利用网络来通信 
### 1.9 重要主题
#### 1.9.1 Amdahl 定律(阿姆达尔定律)
* 用于分析计算系统性能的定律
* S = Told / Tnew
* S = 1/((1 - a) + a/k)

#### 1.9.2 并发和并行
* 线程级并发
> 多核处理器结构，L1，L2在每一个核的内部，L3在核的外部CPU内部是所有核共享的一块高速缓存

> 多核处理器可以从两方面提高系统性能，1是减少使用并发，2是提高应用程序速度（当然应用程序必须以多线程方式编写，这些线程可以并行执行）

> 线程级并发我的理解与进程并发原理相同，比如，一个线程必须要等到数据加载到L1高速缓存中，那么此时CPU就可以去执行另外一个线程。

* 指令级并行
> 指令流水线, 将一条指令拆分成不同的步骤，将处理器的硬件组织成一系统阶段，每个阶段执行一个步骤，这些阶段并行的执行，用来处理不同指令的不同部分。

* 单指令多数据并行(SIMD) 

#### 1.9.3 计算机系统中抽象的重要性 
* 指令集架构是对实际处理器硬件的抽象，这样机器代码表现得好像运行在一个一次只执行一条指令的处理器上一样。

### 1.10 小结
* 计算机系统是硬件和系统软件组成的，它们共同协作让应用程序可以运行。

## 第二章 信息的表示和处理 
* 学习目标？
> 数据类型是如何表示的?

> 硬件是如何实现的？如，CPU是如何实现的？这些硬件是如何被用来执行指令的？

> 程序是如何表示的? 如何执行的?

* 二进制数－－－数字革命的基础
> 在构造存储和处理信息的机器时，二进制工作得更好。二进制可以很容易被表示，如：电平的高低、磁的两极、打孔机的孔。

* 程序员需要对计算机运算与人类熟悉的整数和实数运算之间的关系有清晰的理解

* C的几个不同版本 
> GNU 89, GCC命令行无配置选项时，或-std=gnu89时，使用GNU 89版本的C语言进行编译

> ANSI C, ISO C90, GCC命令行选项使用-ansi, 或 -std=c89时，使用

> ISO C99, GCC命令行使用选项 -std=c99

> ISO C11, GCC命令行使用选项 -std=c11

### 2.1 信息存储
* C语言中，一个指针的值，无论它指向什么数据结构（整数、结构或某个其他程序对象），它都是某个存储块第一个字节的虚拟地址。

* 大概理解了，为什么为有虚拟地址空间这个概念，因为要统一程序自身的差异，这样编译器和运行时系统才可以知道如何用内存来存放不同的程序对象。

* C编译器维护指针类型，但它编译出来的机器指令中没有数据类型相关信息。其实是这样，数据类型是告诉程序需要从指针所指的地址处读多长的数据，
  如int *p; int表示指针p所指向的地址处有四个字节的数据是有效的，在p++时，指针p会移动四个字节；而前面说的四个字节是由数据类型int而得到的。

#### 2.1.1 十六进制表示法  
* 10进制数转16进进制方法
> 举例说明：10进制数188转成16进制
  188 = 11 * 16 + 12   ---> C
  11 = 0 * 16 + 11     ---> B
  所以，十进制数188对应的十六进制数为0xBC
> 这里需要注意的是第一，下次等号左面的数是上一个等式中乘16的那个数
                  第二，最后一个等式的余数是十六进制数的最高位

* 16进制转10进制方法
> 举例说明: 16进制数0x3C转换成10进制数x
  x = 3 * (16 * 1) + 12 * (16 * 0) = 60
                |               |
            16的一次方       16的0次方
                
* 16进制转2进制方法
> 举例说明: 16进制数0x12转换成2进制数x
  x = 0001 0010
       |    |
       1    2

#### 2.1.2 字数据大小
* 每台计算机都有一个字长，指明指针数据的标称大小。虚拟地址是以这样一个字来编码的。

|C声明||字节数|字节数|
|:-|:-|:-|:-|
|有符号|无符号|32位|64位|
|char|unsigned char|1|1|
|short|unsigned short|2|2|
|int|unsigned|4|4|
|long|unsigned long|4|8|
|int32_t|uint32_t|4|4|
|int64_t|uint64_t|8|8|
|char*||4|8|
|float||4|4|
|double||8|8|

> int32_t, int64_t是ISO C99引入的，这种类型长度固定，不会因为编译器和机器设置而变化。
 
* 下面这几个不同的声明表达的意思相同
> unsigned long

> unsigned long int

> long unsigned

> long unsigned int

即关键字顺序不唯一哈

* C语言标准对不同数据类型的数字范围设置了下界，但是没有设置上界
>  没上界，在程序从32位迁移到64位机时可能会出现问题

#### 2.1.3 寻址和字节顺序
* 多字节对象，必须明确两点：
> 对象地址

> 在内存中如何排列这些字节

* 在几乎所有机器上，多字节对象都被存储为连续的字节序列，对象的地址是字节序列中最小的地址。
> 举例说明, int x; 

> 这里假设变量x的地址为0x100，也就是说&x = 0x100，那x的四个字节将被存储在内存的0x100, 0x101, 0x102, 0x103四个地址上。

* 大小端序
> 机器选择将最低有效字节放在最左面－－－小端序

> 机器选择将最高有效字节放在最左面－－－大端序

> 大多数Intel兼容的机器使用小端序

> 较新的微处理器支持双端模式，即可以配置成大端或小端，但是在选择了特定的操作系统之后，那么字节序也同时固定了，如ARM本身支持双端模式，
  但常用的Android或iOS操作系统只能使用小端字节序。

* Intel处理器机器代码文本（其由反汇编器生成）举例：
```as
4004d3: 01 05 43 0b 20 00	add	%eax,0x200b43(%rip)
```
> 首先Intel处理器字节序是小端序

> 其次十六进制字节串01 05 43 0b 20 00是一条指令的字节级表示, 它与add	%eax,0x200b43(%rip)等价

> 取出这条指令字节序列中后四个字节43 0b 20 00，将其反序排列00 20 0b 43，得到值0x00200b43，即0x200b43，这与汇编指令表示中的数值相等。 

* 字节序的另一个应用：强制类型转换或联合，它允许以另外一种数据类型T来引用数据对象，而T与数据对象创建时使用的数据类型t不同。

* man ascii, 查看ascii字符码表

* 看下面这道题
``` c
int x = 0x87654321;
unsigned char* c1 = &x;  
unsigned short * s2 = &x;
// c1, s2的大小端值是什么？
/* 大端
   地址：1   2   3   4
     值：87  65  43  21

   小端
   地址：1   2   3   4
     值：21  43  65  87

     *c1大端值等于87;
     *c1小端值等于21;

     *s2大端值等于87 65;
     *s2小端值等于21 43;

     这里需要明确变量的地址是怎么定义的，指针c1, s2的地址是其所指向字节序列中第一个字节的地址，即最左面的那个字节对应的地址。
     以变量x来说明，大端字节序时，c1的地址就是87的地址，s2的地址也是87；小端序时，c1的地址是21的地址，s2的地址与c1相同，都是指向&x;
   
   */

```
#### 2.1.4 表示字符串
* 在使用ASCII码作为字符码的任何系统上，其值与字节序无关。即，在大端或小端机器上输出任意字符串（如"12345"）得到的结果都是相同的（31 32 33 34 35）
> 因此，文本字符串类型的数据比二进制数据在平台移植上更占优势。

* strlen，它不计算字符串中终止的空字符null，所以strlen("12345")=5，而实际上"12345"的长度是6，因为还有一个\0

* 二进制代码很少能在不同机器和操作系统组合之间移植
> 从机器的角来看，程序仅仅是字节序列。机器没有关于原始源程序的任何信息。

* UTF-8是变长编码的，所有ASCII字节序列用ASCII码表示和用UTF-8码表示是一样的 

* Unicode是定长4字节编码的

#### 2.1.6 布尔代数简介
* TRUE, FALSE------> 1, 0

* 与运算&, 或运算|, 异或运算^
> 1 & 1 = 1;  1 & 0 = 0;  0 & 0 = 0;

> 1 | 1 = 1;  1 | 0 = 1;  0 | 0 = 0;

> 1 ^ 1 = 0; 1 ^ 0 = 1; 0 ^ 0 = 0;

#### 2.1.7 C语言中的位级运算
* 位级运算常用于实现掩码运算, 表示从一个字中选出的位的集合
> 举例说明，掩码0xFF表示取一个字的低8位，如x&0xFF, x = 0x89ABCDEF, 那么x & 0xFF = 0xEF

* ~0将生成一个全1的掩码，对于32位机器可以写成0xFFFF FFFF，但这样的代码是不能移植的

* 练习题2.12对于下面的值，写出变量x的C语言表达式。你的代码应该对任何字长w>=8都能工作。我们给出了当x=0x87654321以及w=32时表达式求值的结果，
仅供参考。
>A. x的最低有效字节，其他位均设置为0。 [0x00000021]。
```c
// 作答如下
  x = x & 0xFF; // 因为值以十六进制表示时两个十六进制数表示一字节，所以掩码为0xFF
```

>B. 除了x的最低有效字节外，其他的位都取补，最低有效字节保持不变。[0x789ABC21]。
```c
// 作答如下
x = x^~0xFF;

```

>C. x的最低有效字节设置成全1，其他字节都保持不变。[0x876543FF]
```c
// 作答如下
x = x|0xFF;

```
* 异或运算x^y = (x&~y)|(~x&y)

#### 2.1.8 C语言中的逻辑运算	
* 逻辑与运算&&
* 逻辑或||
* 逻辑非!
> 不要将逻辑运算与位运算混淆

* 练习题2.15只使用位级和逻辑运算，编写一个C语言表达式，它等价于 x==y。
```
答：
当且仅当x的每一位和y相应的每一位匹配时，x^y等于0。然后我们用!来判断一个字是否包含任何非0位。

```
#### 2.1.9 C语言中的移位运算
* 左移<<，如0x87654321 << 4 = 0x76543210, 这就表示把数据向左移动4位，把原值最左面4位删除，同时把原值最右面4位用0补上。
* 右移>>，机器一般支持两种右移，逻辑右移和算术右移。
> 几乎所有的编译器和机器组合都对有符号数使用算术右移，而对无符号数采用逻辑右移。

* 位移量如果超出了数值实际长度，则对位移量取模做为位移量，举例如下 
```c
int v1 = 0xFEDCBA98 << 32;
int v2 = 0xFEDCBA98 >> 36;
unsigned v3 = 0xFEDCBA98u >> 40;

/* v1 左移32位，而其是int 类型，长度为4字节，正好32位，那么它实际上移动的位数是0，即32 mod 32 = 0;
   v2 右移36位，同要是int类型，数据长度为32位，所以36 mod 32 = 4, 所以其实际移动的位移量是4;
   v3 右移40位，是无符号的int类型，数据长度为32位，所以 40 mod 32 = 8, 所以其实际移动的位移量是8；
 */
```

* 在C语言中，加法、减法的优先级比移位运算高
```c
  1<<2+3<<4 = 1 << (2 + 3) << 4 = 512 // 2^9
```

### 2.2 整数表示
#### 2.2.1 整型数据类型
#### 2.2.2 无符号数的编码
#### 2.2.3 补码编码
* 有符号数最常见的表示方式是补码 
* 补码的计算举例
```asm
  //二进制值0001 = -0 * 2^3 + 0 * 2^2 + 0 * 2^1 + 0 * 2^0 = 0 + 0 + 0 + 1 = 1;
  //二进制值0101 = -0 * 2^3 + 1 * 2^2 + 0 * 2^1 + 1 * 2^0 = 0 + 4 + 0 + 1 = 5;
  //二进制值1011 = -1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 * 2^0 = -8 + 0 + 2 + 1 = -5;
  //二进制值1111 = -1 * 2^3 + 1 * 2^2 + 1 * 2^1 + 1 * 2^0 = -8 + 4 + 2 + 1 = -1;

  //0x2e0对应二进制值为 0010 1110 0000 = 1 * 2^9 + 1 * 2^7 + 1 * 2^6 + 1 * 2^5 = 512 + 128 + 64 + 32 = 736; 
  //-0x58对应二进制值为 -(0101 1000) = -(1 * 2^6 + 1 * 2^4 + 1 * 2^3) = -(64 + 16 + 8) = -88;
  //-0x30对应二进制值为 -(0011 0000) = -(1 * 2^5 + 1 * 2^4) = -(32 + 16) = -48;
  //上面的值是由反汇编器生成的ASCII码形式的程序

  4004d0: 48 81 ec e0 02 00 00	sub	$0x2e0,%rsp
  4004d7: 48 8b 44 24 a8	mov 	-0x58(%rsp),%rax
  4004ec: 48 03 47 28		add	0x28(%rdi),%rax
  4004e0: 48 89 44 24 d0	mov	%rax,-0x30(%rsp)

```
#### 2.2.4 有符号数和无符号数之间的转换
* C语言允许在各种不同的数字数据类型之间做强制类型转换
* 对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能会变，但是各位对应的值保持不变
* 无符号数的最大值与有符号数的-1，这两者的位表示的内容是相同的

* 补码转换为无符号数
```
	假设有符号数x
	无符号数＝x + 2^w,	当x < 0时
	        ＝x，		当x >= 0时
```

* 无符号数转换为补码
```
	假设无符号数u
	补码＝u,		当u <= 有符号数最大值时
            ＝u - 2^w,		当u > 有符号数最大值时
```
#### 2.2.5 C语言中的有符号数与无符号数
* 通常，大多数数字都是有符号的
* 要创建一个无符号常量，必须加上后缀符'U'或者'u', 例如：12345U, 或者12345u
* C语言允许有符号数和无符号数之间的转换

* 当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制转换为无符号数，并假设这两个数都是非负的，之后再执行这个运算

#### 2.2.6 扩展一个数字的位表示
* 无符号数的0扩展
* 补码数的符号扩展
```c
short sx = -12345;		// 对应的十六进制值: cf c7
unsigned short usx = sx;        // 对应的十六进制值: cf c7
int x = sx;			// 对应的十六进制值: ff ff cf c7
unsigned ux = usx;		// 对应的十六进制值: 00 00 cf c7
```
* 练习题2.23
```c
int fun1(unsigned word)
{
	return (int)((word << 24) >> 24);
}

int fun2(unsigned word)
{
	return (((int) word << 24) >> 24);
}

```
|w|fun1(w)|fun2(w)|
|:-|:-|:-|
|0x00000076|0x00000076|0x00000076|
|0x87654321|0x00000021|0x00000021|
|0x000000c9|0x000000c9|0xffffffc9|
|0xEDCBA987|0x00000087|0xffffff87|

> 解题思路: 左移都是逻辑左移，右移分两种，一个逻辑右移，一个算术右移，有符号数是算术右移，而无符号数是逻辑右移。

> 解题思路：不必考虑在将无符号数强制转换为有符号数后w的值是正是负，而只需要考虑右移是什么右移。 

#### 2.2.7 截断数字
#### 2.2.8 关于有符号数与无符号数的建议
```c
float sum_elements(float a[], unsigned len)
{
	int i;
	float res = 0;

	for(i = 0; i <= len - 1; i++)
		res += a[i];
	return res;
}
/*
   当参数len=0时，运行这段代码应该返回0.0。但实际上，运行时会遇到内存错误。请解释为什么，并说明如何修改代码。
   答：
   len是无符号整型，那么当len = 0时 len - 1等价于0u - 1 = -1u = 0xFFFFFFFF;这是无符号值最大值
   那么for循环访问数组a时，将会出现越界访问，从而出现内存错误。

   修改代码的方法：
   将for循环中的终止条件修改为i < len;
   或者，将len 修改为int类型。
 
 */
```

* 无符号类型和有符号类型参数相互传递时，因为C语言中的隐式转换会让程序员写的程序出现不易发现的错误，建议统一参数类型以避免类似问题
 
### 2.3 整数运算
#### 2.3.1 无符号加法
* 无符号数加法溢出检测
```c
int uadd_ok(unsigned x, unsigned y)
{
	unsigned sum = x + y;
	return sum >= x;
}
```
#### 2.3.2 补码加法
* 做补码加法时，必须明确当结果太大（为正）或者太小（为负）时，应该做些什么
* x + y, x和y都是4位长的，那么当

```
 x + y >= 2^3时，正向溢出
 x + y < -2^3时，负向溢出
 /*
  * 这就是说补码加法原理是：
  * 1, x + y = x + y - 2^w, 2^(w-1) <= x + y --------------> 正溢出
  * 2, x + y = x + y,  -2^(w-1) <= x + y < 2^(w-1)
  * 3, x + y = x + y + 2^w, x + y < -2^(w-1)－－－－－－－－>负溢出
  * w 是参数x, y 的位长
  */
```
* 补码加法溢出检测
```c
int tadd_ok(int x, int y)
{
	int sum = x + y;
	int negover = x < 0 && y < 0 && sum >= 0;
	int plusover = x > 0 && y > 0 && sum <= 0;
	return !negover && !plusover;
}
```

|x|y|x + y|x + t5y|情况|
|:-|:-|:-|:-|:-|
|[10100]|[10001]|x = -1 * 2^4 + 1 * 2^2 = -12, y = -1 * 2^4 + 1 * 2^0 = -15, x + y = -12 -15= -27 < -2^4|-27+2^5=5|负溢出|
|[11000]|[11000]|x = -8, y = -8; x + y = -16;|-16|正常|
|[10111]|[01000]|x = -9; y = 8; x + y = -1;|-1|正常|
|[00010]|[00101]|x = 2; y = 5; x + y = 7;|7|正常|
|[01100]|[00100]|x = 12; y = 4; x + y = 16; 16 >= 2^4|16 - 2^5=-16|正溢出|

#### 2.3.3 补码的非
* 补码的非-twx = TMinw, x = TMinw;
          -twx = -x, 	x < TMinw;

* 在C语言中，对于任意整数值x, 计算表达式-x和~x+1得到的结果完全一样	  

* 根据x的补码表示，填写下表，确定x的加法逆元
|x的十六进制|x的十进制|x补码的非（十进制）|x补码的非(16进制)|
|:-|:-|:-|:-|
|0|0|0|0|
|5|5|-5|1011=0xB|
|8|8|-8|1000=0x8|
|D|-3|3|0011=0x3|
|F|-1|1|0001=0x1|

* 练习题2.34
|模式|x|y|x*y|截断的x*y|
|:-|:-|:-|:-|:-|
|无符号|[100]|[101]|4 * 5 = 20 [010100]|4 [100]|
|补码|[100]|[101]|-4 * (-3) = 12 [001100]|-4 [100]|
|无符号|[010]|[111]|2 * 7 = 14 [001110]|6 [110]|
|补码|[010]|[111]|2 * (-1) = -2 [000110]| -2 [110]|
|无符号|[110]|[110]|6 * 6 =36 [010100]| 4 [100]|
|补码|[110]|[110]|-2 * (-2) = 4 [000100]| -4[100]|

* 检测有符号数相乘是否产生溢出tmult_ok
```c
int tmult_ok(int x, int y)
{
	int p = x * y;
	return !x || p/x == y;
}
 // 可用于乘法溢出检测
```
#### 2.3.6 乘以常数
* 大多数机器上乘法指令相当慢，需要10个或更多时钟周期，然而其他整数运算（如，加法，减法，位级运算和移位）只需要1个时钟周期
> 因此，编译器使用了移位和加减法组合的形式来替换原来的乘以常数的运算。

```c
#define K = 14;
int x;

x * K;
// K是常数14, 14 = 2^3 + 2^2 + 2^1 = 8 + 4 + 2
x * K = (x << 3) + (x << 2) + (x << 1); // 这样就将一个乘以常数的运算变成了移位和加法运算。
```

#### 2.3.7 除以2的幂
* 在大多数机器上，整数除法比整数乘法更慢，需要30个时钟周期或更多
* 除以2的幂的运算可以用右移运算来实现
* 无符号和补码数分别使用逻辑移位和算术移位来实现

##### 除以2的幂的无符号除法
* 执行一个逻辑右移k位与除以2^k再舍入到零有一样的效果

##### 除以2的幂的补码除法，向下舍入
* 算术右移类似于除以2的幂，除法是向下舍入，而不是向零舍入

##### 除以2的幂的补码除法，向上舍入
* 右移之前加上一个偏量，结果就向零舍入了
> 这个适当的偏量是如何确定的？

##### 除以2的幂可以通过逻辑或算术右移来实现。但是，这种方法不能推广到除以任意常数

#### 2.3.8 关于整数运算的最后思考

### 2.4 浮点数 
* 浮点数表示对形如V = x * 2^y的有理数进行编码
* IEEE, 电气和电子工程师协会

#### 2.4.1 二进制小数
|二进制表示|值|十进制|
|:-|:-|:-|
|0.0|0/2|0.0|
|0.1|1/2|0.5|
|0.01|1/4|0.25|
|0.001|1/8|0.125|
|0.0001|1/16|0.0625|

* 假定只考虑有限长度的编码，那么十进制表示法不能准确表达像1/3，5/7这样的数
* 小数的二进制表示法只能表示那些能够被写成x * 2^y的数。其他的值只能够近似地表示
> 比如值1/10, 10是十进制数，它的二进制表达式是一个无穷序列0.000110011[0011]......

#### 2.4.2 IEEE浮点表示
* IEEE浮点标准V=(-1)^s * M * 2^E
> s符号，M是尾数(二进制小数，也称为小数域？)，E是阶码
* 单精度浮点格式中，s占一位，E占8位，M占23位
* 双精度浮点格式中，s占一位，E点11位，M占52位

* NaN表示Not a Number，不是一个数
* 偏置--->biased

##### 规格化的值
* 阶码的位中不全为0也不全为1
* E = e - Bias, 其中e是无符号数, Bias等于2^(阶码位数-1) - 1

##### 非规格化的值
* 阶码所有位都是0
* E = 1 - Bias

##### 特殊值 
* 阶码所有位全为1
* 当我们把两个非常大的数相乘，或者除以0时，无究能够表示溢出的结果

#### 2.4.3 数字示例

#### 2.4.4 舍入
* 因为浮点运算只有有限的范围和精度，所以浮点运算只能近似地表示实数运算

#### 2.4.5 浮点运算
* 浮点加法不具有结合性
* 浮点乘法在加法上不具有分配性

#### 2.4.6 C语言中的浮点数
* 当在int, float, double格式之间进制强制类型转换时，程序改变数值和位模式原则如下
> 从int转换成float, 数字不会溢出，但是可能舍入

> 从int或float转换成double时，因为double有更大的范围，也有更高的精度，所以能够保留精确的数值

> 从float或double转换成int，值会向0舍入。例如1.999会被转换成1；-1.999将被转换成-1。进一步来说，值可能会溢出。

* 将大的浮点数转换成整数是一种常见的程序错误来源

### 2.5 小结 
* 整数、实数、字符串分别有不同的编码方式来表示
* 大多数机器对整数使用补码编码
* 大多数机器对浮点数使用IEEE标准754编码
* 相同长度的无符号和有符号整数之间进行强制类型转换时，大多数C语言实现原则是位模式不变，即二进制位的值相同 
* 浮点运算只有有限的范围和精度，且不支持算术运算属性中的结合性

## 第三章 程序的机器级表示 
* 计算机执行机器代码
* 用高级语言写程序的最大优点是，可以在很多不同的机器上编译和执行，而汇编代码则只与特定的机器密切相关
* 精通细节是理解更深和更基本概念的先决条件
* x86-64是笔记本和台式机中最常见处理器的机器语言 
> 同时也是大型数据中心、超级计算机的最常见处理器的机器语言

> IA32是一种重要的机器语言

* AMD------> Advanced Micro Devices

### 3.1 历史观点
> Intel处理器，人称x86发展历史
* 8086（1978年, 29K个晶体管）
* 80286（1982年，134K个晶体管）
* i386（1985年，275K个晶体管）
* i486（1989年，1.2M个晶体管）
* Pentium（1993年，3.1M个晶体管）
* PentiumPro（1995年，5.5M个晶体管）
* Pentium/MMX（1997年，4.5M个晶体管）
* Pentium II（1997年，7M个晶体管）
* Pentium III（1999年，8.2M个晶体管）
* Pentium 4（2000年，42M个晶体管）
* Pentium 4E（2004年，125M个晶体管），增加了超线程；还增加了EM64T（实现64位扩展）
* Core 2（2006年，291M个晶体管），Intel的第一个多核处理器，不支持超线程 
* Core i7, Nehalem（2008年，781M个晶体管），同时支持多核和超线程
* Core i7, Sandy Bridge（2011年，1.17G个晶体管）
* Core i7, Haswell（2013年，1.4G个晶体管）

* Intel处理器系列有好几个名字，包括IA32（Intel Architecture 32-bit, Intel 32位体系结构） 
  Intel64，它是IA32的64位扩展，我们称为x86-64

### 3.2 程序编码
* gcc可以使用cc来启动
* gcc -Og -S hello.c与gcc -O1 -S hello.c中编译器优化选项-Og与-O1相同；-S表示只生成汇编代码；
* gcc 编译器优化等级越高性能越好，但对应更高的优化等级其产生的机器代码和源代码之间的关系越难以理解

#### 3.2.1机器级代码
* 机器语言编程有两种抽象  
> ISA（Instruction Set Architecture指令集架构）来定义机器级程序的格式和行为，它定义了处理器状态、指令格式，及每条指令对状态的影响
 
> 机器级程序使用的内存地址是虚拟地址，内存模型是一个非常大的字节数组

* x86-64的机器代码和原始的C语言代码差别非常大，一些通常对C语言程序员隐藏的处理器状态都是可见的：
> 程序计数器（通常称为PC，在x86-64中用%rip表示）给出将要执行的下一条指令在内存中的地址

> 整数寄存器，包含16个，每一个可存储64位的值。这些寄存器可以存储整数或地址（C语言的指针）。有些寄存器用于记录程序状态，有些用于临时保存数据，如函数的参数和局部变量，以及函数的返回值

> 条件码寄存器，用于保存最近执行的逻辑或算术运算指令的状态信息，它们用于实现控制或数据流中的条件变化，比如实现if或while语句

> 向量寄存器，可以存放一个或多个整数或浮点数值

* 在机器代码中无数据类型的定义，即不会区分C语言中的数据类型，其只是会使用一组连续的字节来表示

* 程序内存包含
> 程序的可执行机器代码

> 操作系统需要的一些信息 

> 用来管理过程调用和返回的运行时栈

> 用户分配的内存块

* 程序内存用虚拟地址来寻址

* 在任意给定时刻，只有有限的一部分虚拟地址是合法的

* 操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址

* 一条机器指令只执行一个非常基本的操作
> 例如，将存放在寄存器中的两个数字相加

> 例如，在储存器和寄存器之间传递数据

> 例如，条件分支转移到新的指令地址

> 编译器必须产生这些指令的序列，从而实现程序结构!!!!!!!!

#### 3.2.2 代码示例
* 机器执行的程序只是一个字节序列，它是对一系列指令的编码

* 机器对产生这些指令的源代码几乎一无所知

* 反汇编器
``` shell
$: objdump -d hello.o
hello.o：     文件格式 elf64-x86-64


Disassembly of section .text:

0000000000000000 <main>:
   0:   48 83 ec 08             sub    $0x8,%rsp
   4:   bf 00 00 00 00          mov    $0x0,%edi
   9:   e8 00 00 00 00          callq  e <main+0xe>
   e:   bf 00 00 00 00          mov    $0x0,%edi
  13:   e8 00 00 00 00          callq  18 <main+0x18>
  18:   b8 00 00 00 00          mov    $0x0,%eax
  1d:   48 83 c4 08             add    $0x8,%rsp
  21:   c3                      retq
```
> x86-64的指令长度从1到15个字节不等

> 设计指令格式的方式是，从某个给定的位置开始，可以将字节唯一地解码成机器指令, 例如，只有pushq %rbx是以字节值53开头

> 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码

> 反汇编器使用的指令命名规则与GCC生成的汇编代码使用的有些细微差别 

* 链接器的任务中包含为函数调用找到匹配的可执行代码位置

* 为了提高存储器系统性能，能更好的放置下一块代码块，链接器可能会在函数代码末尾增加nop(一个nop占一字节)指令来使函数代码长度变成16字节

#### 3.2.3 关于格式的注释
* ATT格式汇编代码, AT&T，它是运营贝尔实验式的公司
> ATT是GCC、objdump和其他一些我们使用的工具默认格式

* 与ATT格式对应的是Intel格式
``` shell
cc -Og -S -masm=intel hello.c

# 使用上面的参数gcc可以产生Intel格式的汇编代码

```
> 在Microsoft和Intel文档中的汇编使用的就是Intel格式的汇编

#### 3.3 数据格式
* 由于Intel是从16位体系结构扩展成32位的，Intel用术语“字（word）“来表示16位数据类型。称32位数为”双字（double words）”，称64位数为“四字（quad words）”

* C语言数据类型在x86-64中的大小
|C声明|Intel数据类型|汇编代码后缀|大小（字节）|
|:-|:-|:-|:-|
|char|字节|b|1|
|short|字|w|2|
|int|双字|l|4|
|long|四字|q|8|
|char*|四字|q|8|
|float|双字|s|4|
|double|四字|l|8|

* 大多数gcc生成的汇编代码指令都有一个字符的后缀，表明操作数的大小 
> 例如，数据传送指令有四个变种: 
```asm
	movb        // 传送字节
	movw        // 传送字
	movl        // 传送双字, 后缀l表示双字，因为32位数被看成是“长字（long word）”
	movq        // 传送四字

```
* 汇编代码与使用后缀l来表示4字节整数和8字节双精度浮点数，这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器

### 3.4 访问信息
* 整数寄存器, 所有16个寄存器的低位部分都可以作为字节、字（16位）、双字（32位）和四字（64位）数字来访问
|63~0|31~0|15~0|7~0|说明|
|:-|:-|:-|:-|:-|
|%rax|%eax|%ax|%al|返回值|
|%rbx|%ebx|%bx|%bl|被调用者保存|
|%rcx|%ecx|%cx|%cl|第4个参数|
|%rdx|%edx|%dx|%dl|第3个参数|
|%rsi|%esi|%si|%sil|第2个参数|
|%rdi|%edi|%di|%dil|第1个参数|
|%rbp|%ebp|%bp|%bpl|被调用者保存|
|%rsp|%esp|%sp|%spl|栈指针|
|%r8|%r8d|%r8w|%r8b|第5个参数|
|%r9|%r9d|%r9w|%r9b|第6个参数|
|%r10|%r10d|%r10w|%r10b|调用者保存|
|%r11|%r11d|%r11w|%r11b|调用者保存|
|%r12|%r12d|%r12w|%r12b|被调用者保存|
|%r13|%r13d|%r13w|%r13b|被调用者保存|
|%r14|%r14d|%r14w|%r14b|被调用者保存|
|%r15|%r15d|%r15w|%r15b|被调用者保存|

* 8086中有8个16位寄存器，即上图中的%ax~%sp
* IA32架构时，寄存器扩展成了32位寄存器，标号从%eax到%esp
* 到x86-64后，原来的8个寄存器扩展成64位，标号从%rax到%rsp；并且增加了8个新的寄存器从%r8到%r15

#### 3.4.1 操作数指示符
* x86-64支持三种操作数：立即数、寄存器、内存引用
* 大多数指令有一个或多个操作数，用来指出执行一个操作时需要使用的源数据值，以及放置结果的目的位置

* 立即数，在ATT格式汇编中，使用$后面跟一个用标准C表示法表示的整数，如$-577或$0x1F；不同的指令对应不同的立即数范围，汇编器会自动选择最紧凑的方式进行数值编码

* 寄存器，

* 内存引用，它会根据计算出来的地址（通常称为有效地址）访问某个内存位置

* 寻址模式

#### 3.4.2 数据传送指令
* 练习题3.3 当我们调用汇编器的时候，下面代码的每一行都会产生一个错误，解释哪里出了问题
```asm
movb $0xF,(%ebx)       //%ebx不能做地址寄存器
movl %rax,(%rsp)       //指令与操作数不匹配。 应当使用movq; 
movw (%rax),4(%rsp)    //操作数不能同时都是内存地址
movb %al,%sl           //没有%sl
movq %rax,$0x123       //立即数不可做结果存储
movl %eax,%rdx         //目的操作数过大，应为%edx
movb %si,8(%rbp)       //指令与操作数长度不匹配; %si是双字节，所以应当用movw 
```

* 零扩展数据传送
> 这些指令以寄存器或内存地址做为源，以寄存器做为目的地

```asm
movzbw
movzbl
movzbq
movzwl
movzwq
```

* 符号扩展数据传送
> 这些指令以寄存器或内存地址做为源，以寄存器做为目的地

```asm
movsbw
movsbl
movsbq
movswl
movswq
movslq
cltq           // 把%eax符号扩展到%rax
```
#### 3.4.3 数据传送示例
#### 3.4.4 压入和弹出栈数据
* 栈可以实现为一个数组，总是从数组的一端插入和删除元素。这一端被称为栈顶

* 栈只有一个出入口（栈顶），所以栈的原则是后进先出

* 栈指针%rsp总是指向栈顶（也就是说寄存器rsp中保存的值是栈顶的内存地址）

* 将四字数据压入栈中
```asm
pushq %rbp
// 它等价于下同这两条
subq $8,%rsp
movq %rbp,(%rsp)
```

* 将四字数据弹出栈
```asm
popq %rdx
// 它等价于下面两条命令
movq (%rsp),%rdx
addq $8,%rsp
```

### 3.5 算术和逻辑操作 
#### 3.5.1 加载有效地址
#### 3.5.2 一元和二元操作
* 练习题3.8 假设下面的值存放在指定的内存地址和寄存器中：
|地址|值|
|:-|:-|
|0x100|0xFF|
|0x108|0xAB|
|0x110|0x13|
|0x118|0x11|

|寄存器|值|
|:-|:-|
|%rax|0x100|
|%rcx|0x1|
|%rdx|0x3|

填写下表，给出下面指令的效果，说明将被更新的寄存器或内存位置，以及得到的值

|指令|目的|值|
|:-|:-|:-|
|addq %rcx,(%rax)|0x100|0xFF+1=0x100|
|subq %rdx,8(%rax)|0x108|0xAB-3=0xA8|
|imulq $16,(%rax,%rdx,8)|0x100+0x3*8=0x118|0x11*16=0x110| 注: 0x11*16相当于二进制数左移16位，16位二进制正好是16进制的一位
|incq 16(%rax)|0x100+0x10=0x110|0x13+0x1=0x14|
|decq %rcx|%rcx|0|
|subq %rdx,%rax|%rax|0x100-0x3=0xFD|

#### 3.5.3 移位操作
* 两个操作数，第一个是移位量，第二个是被移位的数
* 移位量可以是立即数，或%cl
* 因为64位长的数据值最多移位量超不过64，所以可以用一字节的%cl寄存器来编码移位量2^8 - 1 = 255位, 即只使用%cl的低m位决定, 2^m = 被移位数值的位数，
  %cl的高位会被忽略

#### 3.5.4 讨论 
##### 练习题3.11 常常可以看见以下形式的汇编代码行
```asm
xorq %rdx,%rdx
```
* 但是在产生这段汇编代码的C代码中，并没有出现EXCLUSIVE-OR操作

* A. 解释这条特殊的EXCLUSIVE-OR指令的效果，它实现了什么有用的操作。
> 因为x ^ x = 0;  所以可以利用异或操作来置0，即x=0;

* B. 更直接地表达这个操作的汇编代码是什么?
```asm
movq $0,%rdx
```
* C. 比较同样的一个操作的两种不同实现的编码字节长度
> 这个需要使用nm, as，加上汇编程序来具体查看
> 第一步，写如下程序，并将其保存成test.s文件
```asm
a: movq $0,%rdx
b: xorq %rdx,%rdx
c:
```
> 第二步，用汇编器as编译.s，生成test.o机器码
```shell
$: as -o test.o test.s
```

> 第三步，用nm查看test.o
```shell
$: nm test.o

0000000000000000 t a
0000000000000007 t b
000000000000000a t c

// 可以看到
// b - a = 7 - 0 = 7 字节, 对应movq这条指令
// a - 7 = 3 字节，对应xorq这条指令
```

#### 3.5.5 特殊的算术操作
* x86-64指令集对128位（16字节）数的操作提供有限支持
* %rdx, %rax组成一个128位的八字

### 3.6 控制
#### 3.6.1 条件码
* 条件码寄存器，它只有一个位长，用来描述最近的算术或逻辑操作结果
> 条件码寄存器可以用来构建程序的条件分支

|条件码寄存器|作用|功能描述|
|:-|:-|:-|
|CF|进位标志|最近的操作使最高位产生了进位|
|ZF|零标志|最近的操作得出的结果为0|
|SF|符号标志|最近的操作得到结果为负数|
|OF|溢出标志|最近的操作导致一个补码溢出－－正溢出或负溢出|

* 只改变条件码寄存器的两个指令CMP（比较）和TEST（测试）

* CMP指令根据两个操作数之差来设置条件码
```asm
cmpb
cmpw
cmpl
cmpq

CMP s1,s2 基于 s2 - s1
```

* TEST指令与AND指令唯一不同是它只改变条件码寄存器

#### 3.6.2 访问条件码
* 条件码怎么用？
> 用来设置字节为0或1

> 用来跳转

> 传送数据

```
// C语言代码
long cmpx(long a, long b)
{
	return a < b;
}
// 以下汇编实现C语言函数cmpx
cmpq %rsi,%rdi
setl %al        // 当cmpl操作结构为%rdi小于%rsi时，%al被设置成1，否则设置为0
movzbl %al,%eax // 如果C语言函数返回值类型为char的话，就没这句
```
* SET指令
> set指令根据条件码，将一个字节设置成0或1

|指令|效果|设置条件|同义名|
|:-|:-|:-|:-|
|sete	D|D <--- ZF|相等、0|setz|
|setne 	D|D <--- ~ZF|不等、非0|setnz|
|sets	D|D <--- SF|负数||
|setns	D|D <--- ~SF|非负数||
|setg	D|D <--- ~(SF^OF)&~ZF)|有符号的大于|setnle|
|setge	D|D <--- ~(SF^OF)|有符号的大于等于|setnl|
|setl	D|D <--- SF^OF|有符号小于|setnge|
|setle	D|D <---(SF^OF)|ZF|有符号的小于等于|setng|
|seta	D|D <--- ~CF&~ZF|无符号的大于|setnbe|
|setae	D|D <--- ~CF|无符号的大于等于|setnb|
|setb	D|D <--- CF|无符号小于|setnae|
|setbe	D|D <--- CF | ZF |无符号小于等于|setna|

* 所有的算术和逻辑操作都设置条件码

* 无符号数只使用CF和ZF两个寄存器进行比较

* 有符号数需要使用OF,SF,ZF三个寄存器进行判断>,<,=

* 练习题3.13
```
int comp(data_t a, data_t b)
{
	return a COMP b;
}
// 根据下面汇编代码来判断上面C语言函数中变量a,b的数据类型
A.	cmpl	%esi,%edi   	// 由cmpl中的l可知是32位长数据类型
	setl	%al		// 由setl可知是有符号类型
				// 所以A中a,b数据类型一定是int
B.	cmpw	%si,%di		// cmpw中的w，可知是16bit
	setge	%al		// setge说明是有符号数
				// B中的a,b数据类型为short
C.	cmpb	%sil,%dil       // cmpb---->8bit
	setbe	%al		// setbe--->无符号
				// C中a,b类型为unsigned char
D.	cmpq	%rsi,%rdi	// cmpq---->64bit
	setne	%al		// setne--->有无符号都可
				// D的a,b数据类型为long, unsigned long
```

#### 3.6.3 跳转指令
* 跳转指令会导致执行切换到程序中一个全新的位置
> 在汇编代码中，这些跳转的目的地通常用一个标号指明

* 在产生目标代码文件时，汇编器会确定所有带标号指令的地址，并将跳转目的地地址编码为跳转指令的一部分

* jmp是无条件跳转指令，它有三种操作数
> 直接跳转，操作数是标号

> 间接跳转，分两种，从寄存器或内存中读出跳转的目的地地址
```
jmp *%rax	// 这种是用寄存器%rax的值作为跳转地址
jmp *(%rax)	// 这种是以寄存器中保存的值做为内存地址，从内存中读出跳转地址
```

* 条件跳转只能是直接跳转

* jump指令
|指令|跳转条件|描述|同义名|
|:-|:-|:-|:-|
|jmp	Label|1|直接跳转||
|jmp	*Operand|1|间接跳转||
|je	Label|ZF|相等或0||
|jne	Label|~ZF|不相等或非0||
|js	Label|SF|负数||
|jns	Label|~SF|非负数||
|jg	Label|~(SF^OF)&~ZF|有符号大于||
|jge	Label|~(SF^OF)|有符号大于等于||
|jl	Label|SF^OF|有符号小于||
|jle	Label|(SF^OF)|ZF|有符号小于等于||
|ja	Label|~CF & ~ZF|无符号大于||
|jae	Label|~CF|无符号大于等于||
|jb	Label|CF|无符号小于||
|jbe	Label|CF|ZF|无符号小于等于||

#### 3.6.4 跳转指令的编码
* 汇编器生成的目标文件.o它里面还没有每一条机器代码对应的绝对地址，只有当用链接器链接后生成的可执行程序中才包含机器代码的绝对地址
```
// 下面是经汇编器生成的hello.o文件部分内容
// cc -c -o hello.o hello.c
// objdump -d hello.o

0000000000000000 <cmpx>:
   0:   48 39 f7                cmp    %rsi,%rdi
   3:   0f 9c c0                setl   %al
   6:   c3                      retq   

0000000000000007 <cmpy>:
   7:   48 39 f7                cmp    %rsi,%rdi
   a:   0f 9c c0                setl   %al
   d:   0f b6 c0                movzbl %al,%eax
  10:   c3                      retq 

// 下面代码是经链接器链接生成的可执行程序hello文件部分内容
// cc -o hello hello.c
// objdump -d hello

000000000040052d <cmpx>:
  40052d:       48 39 f7                cmp    %rsi,%rdi
  400530:       0f 9c c0                setl   %al
  400533:       c3                      retq   

0000000000400534 <cmpy>:
  400534:       48 39 f7                cmp    %rsi,%rdi
  400537:       0f 9c c0                setl   %al
  40053a:       0f b6 c0                movzbl %al,%eax
  40053d:       c3                      retq
```

##### 实际对比汇编器与链接器输出中跳转指令的操作数
* 1、下面是一段汇编源码，将其保存在文件jmp1.s中
```
movq    %rdi,%rax
jmp     .L2
.L3:
sarq    %rax
.L2:
testq   %rax,%rax
jg      .L3
rep;ret
```
* 2、执行命令as -o jmp1.o jmp1.s将汇编源文件用汇编器编译成目标代码jmp1.o
* 3、执行objdump -d jmp1.o，将目标代码反汇编，如下
```
   	0:   48 89 f8                mov    %rdi,%rax
      	3:   eb 03                   jmp    0x8
        5:   48 d1 f8                sar    %rax
	8:   48 85 c0                test   %rax,%rax
	b:   7f f8                   jg     0x5
	d:   f3 c3                   repz retq 
```

* 4、执行ld -o jmp1 jmp1.o将目标文件链接生成可执行文件jmp1
* 5、执行objdump -d jmp1, 将可执行文件反汇编如下，
```
   400078:   48 89 f8                mov    %rdi,%rax
   40007b:   eb 03                   jmp    400080 <__bss_start-0x200007>
   40007d:   48 d1 f8                sar    %rax
   400080:   48 85 c0                test   %rax,%rax
   400083:   7f f8                   jg     40007d <__bss_start-0x20000a>
   400085:   f3 c3                   repz retq 
```
* 总结
> 观察3和5两段反汇编代码中jmp跳转指令的操作数，3是中是相对地址，5中是绝对地址

* 练习题 3.15在下面这些反汇编二进制代码中，有些信息被X代替了，回答下列关于这些指令的问题
```
A. 下面je指令的目标是什么？
	4003fa: 74 02	je	XXXX
	4003fc: ff d0	callq	*%rax
	
	答：
	XXXX = 4003fc + 2 = 4003fe

B. 下面je指令的目标是什么？
	40042f: 74 f4	je	XXXX
	400431: 5d	pop 	%rbp
	答：
	XXXX = 400431 + f4
	f4表示值为负，即f4 = -1 * 16^1 + 4 * 16 ^0= -12 = -C
	所以，XXXX = 400431 - c = 400425

C. ja和pop指令的地址是多少?
	XXXX: 77 02	ja	400547
	XXXX: 5d	pop	%rbp
	答：
	400547 = pop 的地址Xpop + 2, 所以pop的地址是400547 - 2 = 400545
	ja这条指令是两个字节，所以ja所在的地址Xja = 400545 - 2 = 400543

D. 在下面的代码中，跳转目标的编码是PC相对的，且是一个4字节补码数。字节按照从最低位到最高位的顺序列出，反映出x86-64的小端法字节序。跳转目标的地址是什么?
	4005e8: e9 73 ff ff ff	jmpq	XXXX
	4005ed:	90		nop
	答：
	小端序，所以操作数为ff ff ff 73, 题中说明这是一个四字节的补码数 
	即 -1 * 16^2 + 7 * 16^1 + 3 * 16^0 = -256 + 112 + 3 = -141 对应16进制为-8d 

	XXXX = 4005ed - 8D = 400560

	注意：将一个补码数转换成带正负号的十六进制数之后才可以进行算术运算（如加减法），因为补码数只能与补码数运算。
```

* 如果补码为负数，则必须先将补码数转换成带负号的16进制数后再进行加减运算

#### 3.6.5 用条件控制来实现条件分支 
* 练习题 3.18
> 已知汇编推C语言源码
```asm
test:
	leaq	(%rdi,%rsi),%rax
	addq	%rdx,%rax
	cmpq	$-3,%rdi
	jge	.L2
	cmpq	%rdx,%rsi
	jge	.L3
	movq	%rdi,%rax
	imulq	%rsi,%rax
	ret
	.L3:
	movq	%rsi,%rax
	imulq	%rdx,%rax
	ret
	.L2:
	cmpq	$2,%rdi
	jle	.L4
	movq	%rdi,%rax
	imulq	%rdx,%rax
	.L4
	rep;ret
```
* 根据上面的gcc汇编代码填写下在的C语言代码
```c
long test(long x, long y, long z)
{
	long val = x + y + z;
	if(x < -3){
		if(y < z)
			val = x * y;
		else
			val = y * z;
	}else if(x > 2)
		val = x * z;
	return val;
}
```
#### 3.6.6 用条件传送来实现条件分支
* 条件传送
> 少量列举条件传送指令如下
```
 cmove	S,R
 cmovne	S,R
 cmovl	S,R
 cmovle	S,R
```
> 还有很多条件传送指令

* 条件跳转
* 少数条件表达式可以用条件传送来代替条件跳转


#### 3.6.7 循环
* 汇编中没有与C语言中对应的do-while, while, for指令
* 汇编中实现C语言中的循环是使用条件测试和跳转的组合来达到同样效果的

##### do-while循环
* do-while语句的通用形式如下
```c
do
	body-statement
	while(test-expr);
```
* do-while语句对应的条件＋goto形式如下
```
	loop:
		body-statement
		t = test-expr;
		if(t)
			goto loop;
```
##### while循环
* while语句通用形式如下
```
	while(test-expr)
		body-statement
```

* while语句第一种翻译方法：跳转中间法
```
	goto test;
	loop:
		body-statement
	test:
		t = test-expr;
		if(t)
			goto loop;
	
```
* while语句第二种翻译方法: guarded-do
```
	t = test-expr;
	if(!t)
		goto done;
	loop:
		body-statement
		t = test-expr;
		if(t)
			goto loop;
	done:
```
* 练习题3.26 函数fun_a有如下整体结构:
```c
long fun_a(unsigned long x)
{
	long val = 0;
	while(){
	
	}
	return ...;
}
```

> GCC 编译产生如下代码

```asm
fun_a:
	movl	$0,%eax
	jmp	.L5
	.L6:
	xorq	%rdi,%rax
	shrq	%rdi		  // 这一句表示的是x逻辑右移1位
	.L5:
	testq	%rdi,%rdi
	jne	.L6
	andl	$1,%eax           // 这句的作用是只保留寄存器%eax最后一位的值，高位全部清0; 换算成二进制的与操作会很明显
	ret
```

> A. 确定这段代码使用的循环翻译方法

> B. 根据汇编代码版本填写C代码中缺失的部分

> C. 用自然语言描述这个函数用途

##### for循环
* for循环的通用形式如下
```
	for(init-expr;test-expr;update-expr)
		body-statement
```
* C语言for循环体无continue的for循环与下面的while循环等价
```c
init-expr;
while(test-expr){
	body-statement
	update-expr;
}
```
* 练习题 3.29 在C语言中执行continue语句会导致程序跳到当前循环的结尾。当处理continue语句时，将for循环翻译成while循环的描述规则需要一些改进。
> 如下代码所示

```c
long sum = 0;
long i;
for(i = 0;i < 10; i++){
	if(i&1)
		continue;
	sum += i;
}
```
> A.如果我们简单地直接应用将for循翻译到while循环的规则，会得到什么呢? 产生的代码会有什么错误呢?

```c
while(i<10){
	if(i&1)
		continue;
	sum +=i;
	i++;
}
// 很明显直接替换的话会出现因未更新i的死循环
```

> B.如何用goto语句来替换continue语句，保证while循环的行为同for循环的行为完全一样？
```c
while(i<10){
	if(i&1)
		goto updatei;
	sum += i;
	updatei:
		i++;
}
```
#### 3.6.8 switch 语句
* 跳转表 
* 与一组很长的if-else相比，跳转表优点是执行开关语句的时间与开关数量无关
* GCC什么情况下会使用跳转表?
>  开关数量较多，且开关值范围跨度比较小时使用。

* 思想：跳转表是一种非常有效的实现多重分支的方法

### 3.7 过程 
* 在机器级支持过程，必须处理函数调用过程中的所有动作，这些动作包括如下一个或多个机制
> 传递控制

> 传递数据

> 分配和释放内存

#### 3.7.1 运行时栈
* x86-64的栈向低地址方向增长, 寄存器%rsp指向栈顶
* 当x86-64过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间
* 通用的栈帧结构用来描述每个过程栈的使用情况，栈可以用来传递参数值、存储返回地址、保存寄存器，以及局部变量
* 当一个函数所有的局部变量都可以保存在寄存器中，而且该函数不会调用任何其他函数时，这个函数根本不需要栈帧
#### 3.7.2 转移控制

* call指令与ret指令的一般形式
```
call	Label		//直接调用, Label是被调用函数的起始地址
call	*Operand	//间接调用, *Operand同样是被调用函数的起始地址，只不过地址保存在内存中
ret			//从过程调用中返回
```
* x86-64机器中call指令工作内容包括两个，其一是从函数P跳转到Label指定的函数Q，其二是记录从函数Q返回后继续执行P后续代码位置A

* C语言标准的调用／返回机制刚好与栈提供的后进先出的内存管理方法吻合

* 练习题3.32 下面列出的是两个函数first和last的反汇编代码，以及main函数调用first的代码
```asm
0000000000400540 <last>:
	400540: 48 89 f8	mov	%rdi,%rax
	400543: 48 0f af c6	imul	%rsi,%rax
	400547: c3		retq

0000000000400548 <first>:
	400548: 48 8d 77 01	lea	0x1(%rdi),%rsi
	40054c: 48 83 ef 01	sub	$0x1,%rdi
	400550: e8 eb ff ff ff 	callq	400540 <last>
	400555: f3 c3		repz retq

0000000000400560 <main>:
	400560: e8 e3 ff ff ff	callq	400548 <first>
	400565:	48 89 c2	mov	%rax,%rdx
// 注意，各行前面的地址，它们都是6个16进制组成的，换算成二进制长度是24位	
	 前面的三位全是400不变，变化的只有后面的3个16进制数，3个正好是12位，正好是2^12=4KB，一页的大小
```
> 从main调用first(10)开始，到程序返回main时为止，填写下表记录指令执行的过程

|PC|指令|%rdi|%rsi|%rax|%rsp|*%rsp|描述|
|:-|:-|:-|:-|:-|:-|:-|
|0x400560|callq|10|-|-|0x7fffffffe820|-|调用first(10)|
|0x400548|lea|10|-|-|?|0x400565|PC当前指向lea命令，但还未执行这条命令, 所以对应的寄存器rdi值此刻不变|
|0x40054c|sub|10|11|-|?|0x400565|前面的lea命令执行结束，PC指向sub命令|
|0x400550|callq|9|11|-|?|0x400565||
|0x400540|mov|9|11|-|?|0x400555||
|0x400543|imul|9|11|9|?|0x400555||
|0x400547|retq|9|11|99|?|0x400555||
|0x400555|repz retq|9|11|99|0x400565||
|0x400565|mov|9|11|99||-|

#### 3.7.3 数据传送
##### x86-64可以通过寄存器最多传送6个整型（整数或指针）参数。寄存器使用有特殊顺序，如下所示 
|参数大小|第一个参数|第二个参数|第3参|第4参|第5参|第6参|
|:-|:-|:-|:-|:-|:-|:-|
|64bit|%rdi|%rsi|%rdx|%rcx|%r8|%r9|
|32bit|%edi|%esi|%edx|%ecx|%r8d|%r9d|
|16bit|%di|%si|%dx|%cx|%r8w|%r9w|
|8bit|%dil|%sil|%dl|%cl|%r8b|%r9b|

##### 如果函数有大于6个整型参数，超出6个的部分需要用栈来传递
* 如一个函数有n个参数，且n > 6，把参数1～6复制到寄存器，把参数7～n放到栈上，而参数7位于栈顶(或返回地址上面,即%rsp+8)。通过栈传参数时，所有的数据大小都向8的倍数对齐

* 练习题3.33 C函数procprob有4个参数u,a,v,b，每个参数要么是一个有符号数，要么是一个指向有符号数的指针，这里的数大小不同。该函数的函数体如下
```c
*u += a;
*v += b;
return sizeof(a) + sizeof(b);
```

> 编译后得到如下x86-64代码:

```asm
	procprob:
		movslq	%edi,%rdi
		addq	%rdi,(%rdx)          // 由此命令判断第1个参数是a, 第3个参数是u, 再由前面movslq可知a的类型是int, u是long *
		addb	%sil,(%rcx)          // 此句可知第4个参数是v, 第2个参数是b；且v的类型为char*, 因为这里是用sil寄存器将b的低8位给v，所以v指向的内存是8位
		movl	$6,%eax              // 因a是int 四字节，所以b是6－4＝2字节, 所以b是short
		ret
```

> 确定四个参数类型和合法的参数顺序。有两种答案。
```c
// 答案一、
procprob(int a, short b, long * u, char *v);
// 答案二、
// C语言源码中，如果两个操作执行顺序调整一下，先执行*v+=b,后执行*u+=a不会影响C程序效果，所以答案二为
procprob(int b, short a, long *v, char *u);
```

#### 3.7.4 栈上的局部存储
#### 3.7.5 寄存器中的局部存储空间
* 寄存器是唯一被所有函数共享的资源
* 虽然在给定时刻只有一个函数是活动的，我们仍然必须确保当一个函数P调用另一个函数Q时，被调用者Q不会覆盖调用者P稍后会使用的寄存器，为此x86-64规定如下惯例
> 寄存器%rbx, %rbp和%r12～%r15为“被调用者保存寄存器”，即，被调用的函数Q必须保证在其返回后这些寄存器中的内容与调用Q之前相同（Q可以修改这些寄存器，但在使用前需要将这些寄存器保存到其栈中，在Q执行完后，再将这些寄存器出栈恢复;另一种就是不做修改）

* 寄存器rdi,rsi,rax,rcx,rdx,r8~r11 任何函数都可以修改他们; 
> 这些寄存器，因为任何函数都可以修改，所以调用函数P如果想保留他们，必须在P调用其他函数Q之前，自己负责保存它们

* 练习题 3.34 一个函数P生成名为a0～a7的局部变量，然后调用函数Q，没有参数。GCC为P的第一部分产生如下代码：
```asm
P:
	pushq	%r15
	pushq	%r14
	pushq	%r13
	pushq	%r12
	pushq	%rbp
	pushq	%rbx
	subq	$24,%rsp
	movq	%rdi,%rbx 		// a0
	leap	1(%rdi),%r15		// a1
	leap	2(%rdi),%r14		// a2
	leap	3(%rdi),%r13		// a3
	leap	4(%rdi),%r12		// a4	
	leap	5(%rdi),%rbp		// a5
	leap	6(%rdi),%rax
	movq	%rax,(%rsp)		// a6
	leap	7(%rdi),%rdx
	movq	%rdx,8(%rsp)		// a7
	movq	$0,%eax
	call	Q

```

#### 3.7.6 递归过程
* 调用递归函数与通常的函数一样

### 3.8 数组分配和访问
#### 3.8.1 基本原则
#### 3.8.2 指针运算
* p是一个指向类型为T的数据的指针，p的值为x, 那么表达式p + i = x + L * i, L是数据类型T的大小，以字节为单位
* 练习题3.37 假设短整型数组S的地址x和整数索引i分别存放在%rdx, %rcx中。对下面每个表达式，给出它的类型、值的表达式和汇编代码实现。
|表达式|类型|值|汇编代码|
|:-|:-|:-|:-|
|S+1|short *|x + 1 * 2 = x + 2|leaq 2(%rdx), %rax|
|S[3]|short|M[x + 3*2] = M[x + 6]|movw 6(%rdx),%ax|
|&S[i]|short*|x + i*2 = x + 2i|leaq (%rdx,%rcx,2),%rax|
|S[4*i+1]|short|M[x + 4 * i * 2 + 1*2] = M[x + 8i + 2]|movw 2(%rdx,%rcx,8),%ax|
|S+i-5|short*|x + i*2 - 5*2= x + 2i - 10|leaq -10(%rdx,%rcx,2),%rax|

#### 3.8.3 嵌套的数组
* 有这样的数组
```c
int A[5][3];
// 它等价于下面的声明
typedef int row3_t[3];
row3_t A[5];
// 数据类型row3_t被定义为一个有3个整数的数组。数组A包含5个这样的元素
// 数组A可以被看成5行3列的二维数组

//数组元素在内存中按照“行优先”的顺序排列，这意味着第0行的所有元素可以写成A[0]；第N行的所有元素可以写成A[N]
```

##### 对于一个声明为如下的数组
```c
T D[R][C];
// 它的数组元素D[i][j]的内存地址为：
&D[i][j] = X + L * (C * i + j); // X为数组D的起始地址, L是T以字节为单位的大小 
```

#### 3.8.4 定长数组
* 练习题 3.40 下面的C代码将定长数组的对角线上的元素设置为val
```c
void fix_set_diag(fix_matrix A, int val)
{
	long i;
	for (i = 0; i < N; i++)
		A[i][i] = val;
}
/* 创建一个C代码程序fix_set_diag_opt, 它类似于3-37b的风格。
 */

void fix_set_diag(fix_matrix A, int val)
{
	int * Aptr = &A[0][0];
	int * Aend = &A[N][N];
	do{
		*Aptr = val;
		Aptr += N + 1;
	}while(Aptr != Aend);
}
```

#### 3.8.5 变长数组
* ISO C99引入允许数组的维度是表达式，在数组被分配时才计算出来
> 形如：int A[expr1][expr2];

* 例如要访问n*n数组的元素i,j，我们可以定义如下函数:
```c
int var_ele(long n, int A[n][n], long i, long j){
	return A[i][j];
}
// !!!注意&A[i][0]与A[i]相等
```

### 3.9 异质的数据结构
* C语言提供了两种方法来将不同数据类型的对象组合到一起，结构、联合
```c
struct rec{
	int x;
	int y;
};

struct rec *a;
*a.x会被编译器解释为*(a.x)
a->x与( *a).x相同     // (后面的空格是因.md文件格式所迫

```
#### 3.9.1 结构
* 结构的所有组成部分都存放在内存中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址
* 结构中第一个成员的偏移量为0，所以这个成员的地址就是结构的地址
* 要访问结构中的成员，只需要将结构的地址加上成员的偏移量

#### 3.9.2 联合
* 联合是用不同的字段来引用相同的内存块
```c
union U {
	char c;
	int i[2];
	double v;
};
// 联合U中三个字段的字段偏移量全是0，而整个联合的大小是8，最大字段的大小就是联合的大小
```

* 联合有两种用途
> 第一种、一个数据结构中两个不同字段的使用是互斥的，那么这两个字段可声明为联合，这样可减小分配的空间

> 第二种、访问不同数据类型的位模式

```c
// 下面是强制类型转换例子，此时变量u和d的位表示是不一样的 
double d;
unsigned long u = (unsigned long)d;

// 下面这段代码，u与d的位表示是完全一样的，包括符号位、指数、尾数。但u的值与d的值没有任何关系，除了d=0.00情况。 
unsigned long double2bits(double d)
{
	union {
		double d;
		unsigned long u;
	} temp;

	temp.d = d;
	return temp.u;
}
```

* 练习题3.43 有如下结构声明：
```c
typedef union {
	struct {
		long u;
		short v;
		char w;
	} t1;
	struct {
		int a[2];
		char *p;
	} t2;
} u_type;
// 一组如下形式的函数：
void get(u_type *up, type *dest)
{
	*dest = expr;
}

```
> 这组函数有不一样的表达式expr，且根据expr的类型来设置数据类型type。填写下表:
|expr|type|code|
|:-|:-|:-|
|up->t1.u|long|movq	(%rdi),%rax;movq	%rax,(%rsi)|
|up->t1.v|short|movw	8(%rdi),%ax;movw	%ax,(%rsi)|
|&up->t1.w|char*|addq 	10,%rdi;movq	%rdi,(%rsi)|
|up->t2.a|int*|movq %rdi,(%rsi)|
|up->t2.a[up->t1.u]|int|movq	(%rdi), %rax;movl	(%rdi,%eax,4), %rax;movl %eax,(%rsi)|
|*up->t2.p|char|movb	8(%rdi),%al;movb	%al,(%rsi)|

#### 3.9.3 数据对齐
* 无论数据是否对齐x86-64硬件都能正确工作
* 大多数x86-64指令保持数据对齐能提高效率
* 某些型号的Intel和AMD处理器对多媒体SSE指令如数据不对齐就无法正确执行
> 较新版本的x86-64处理器实现了AVX多媒体指令，该指令不强制要求对齐 

* 练习题3.44 对下面每个结构声明，确定每个字段的偏移量、结构总的大小，以及在x86-64下它的对齐要求:
```c
struct P1{
	int i;     // 偏移量0
	char c;    // 偏移量4
	int j;	   // 偏移量8
	char d;	   // 偏移量12
};
// P1结构总大小16字节；在x86-64下按4字节对齐

struct P2 {
	int i;    	// 偏移量0
	char c;		// 偏移量4
	char d;		// 偏移量5
	long j;		// 偏移量8
};
// P2结构总大小4+1+3+8=16字节；在x86-64下按8字节对齐 

struct P3 {
	short w[3];	// 偏移量0
	char c[3];	// 偏移量6
};
// P3结构总大小2*3 + (1*3 + 1)= 10字节；在x86-64下按2字节对齐 

struct P4 {
	short w[5];	// 偏移量0
	char *c[3];	// 偏移量16
};
// P4结构总大小(2*5+6)+8*3 = 40字节；在x86-64下按8字节对齐

struct P5 {
	struct P3 a[2];	// 偏移量0
	struct P2 t;	// 偏移量24
};
// P5结构总大小(2*10+4)+16 = 40字节；在x86-64下按8字节对齐
```

* 练习题 3.45 有如下结构
```c
struct {
	char 	*a;	// 偏移量0
	short	b;	// 偏移量8
	double 	c;	// 偏移量16
	char 	d;	// 偏移量24
	float	e;	// 偏移量28
	char	f;	// 偏移量32
	long	g;	// 偏移量40
	int	h;	// 偏移量48
} rec;
// 问题如下 
// A. 这个结构中所有的字段的字节偏移量是多少？ 如上

// B. 这个结构总的大小是多少? 8 + (2 + 6) + 8 + (1 + 3) + 4 + (1 + 7) + 8 + 4 = 52字节，
//    因需要按8字节对齐所以结构需为8的倍数，即结构长度为56字节

// C. 重新排列这个结构中的字段，以最小化浪费的空间，然后再给出重排过的结构的字节偏移量和总的大小
struct {
	char 	*a;	// 偏移量0
	double 	c;	// 偏移量8
	long 	g;	// 偏移量16
	float	e;	// 偏移量24
	int 	h;	// 偏移量28
	short	b;	// 偏移量32
	char	d;	// 偏移量34
	char	f;	// 偏移量35
}rec2;
// 调整后总大小: 8 + 8 + 8 + 4 + 4 + 2 + 1 + 1 = 36字节，因需要按8字节对齐，所以取与36最近的40为最终结构大小 

```

### 3.10 在机器级程序中将控制与数据结合起来
#### 3.10.1 理解指针
* 每个指针都对应一个类型
* 通用指针 void *
* 每个指针都有一个值
* 指针用&创建
* 操作符＊用于间接引用指针
* 数组a[3]与*(a+3)效果相同
* 指针从一种类型强制转换成另一种类型，只改变它的类型，不改变它的值
* 指针可指向函数 
> int (*fun)(int*);// 这是声明一个函数指针fun，它有一个int* 类型的参数，返回值是int类型的;不可以将fun外面的括号去了，那样的话定义将变成一个函数定义，而不函数指针

> 函数指针的值是该函数机器代码表示中第一条指令的地址  

#### 3.10.2 使用GDB调试
* info frame // 在gdb里查当前栈信息
* info registers
* disas // 反汇编当前函数
* print /x $rax   // 以16进制形式输出寄存器%rax的内容

#### 3.10.3 内存越界引用和缓冲区溢出
* C语言对于数组引用不进行任何边界检查
* 可以使用缓冲区溢出让程序执行它本来不愿意执行的函数
> 如，输入给程序一个字符串，其中包含一些可执行代码的字节编码，称为攻击代码; 用一些字节保存指向攻击代码的指针覆盖返回地址

* 蠕虫可自己运行, 可将自己的等效副本传播到其他计算机

* 病毒不能独立运行，它能将自己添加到其他程序中

#### 3.10.4 对抗缓冲区溢出攻击
* 栈随机化
* 金丝雀
* 限制可执行代码区域
> 以前的x86体系结构将读和执行访问控制合并成一个1位的标志，这样任何被票房为可读的页也都是可执行的。栈必须是可写可读，所以栈上的字节就变成可执行的

> 最近AMD引入NX位（不执行），将读和执行访问模式分开，Intel（奔腾D处理器起包含；现在的Core I3, I5, I7都有）也跟进了。有了这个特性，栈可以被标记为可读可写，但是不可执行，且检查页是否可执行由硬件完成

#### 3.10.5 支持变长栈帧
* 有些函数需要局部存储是变长的
> 使得alloc

> 局部变长数组

* x86-64使用寄存器%rbp作为帧指针（也称基指针）
> pushq %rbp		// 保存%rbp之前的值到栈中

> movq %rsp,%rbp	// 第二步，将%rbp指向%rsp，之后保持不变

* leave指令用于释放整个栈帧（如，它等价于movq %rbp,%rsp和popq %rbp两条指令组合）

### 3.11 浮点代码
* MMX
> 1997年出现，支持图形和图像处理的媒体指令，它本意是允许多个操作以并行模式执行，称为SIMD，即单指令多数据

> MM 寄存器，64位，即8字节

* SSE
> 流式SIMD扩展

> XMM寄存器，128位，即16字节

> 2000年，奔4引入SSE2

> 对应的寄存器：%xmm0～%xmm15

* AVX
> 高级向量扩展

> YMM寄存器，256位，即32字节

> 2013年Core i7 Haswell处理器引入AVX2

> AVX浮点体系结构允许数据存储在16个YMM寄存器中，名称为%ymm0～%ymm15

#### 3.11.1 浮点传送和转换操作
* GCC只用标量传送操作从内存传送数据到XMM寄存器或从XMM寄存器传送数据到内存

#### 3.11.2 过程中的浮点代码
* x86-64中，XMM寄存器用来向函数传递浮点参数，以及浮点返回值
* XMM寄存器最多中传递8个浮点参数，%xmm0～%xmm7
* 函数使用寄存器%xmm0来返回浮点值
* 所有XMM寄存器都由调用者保存

* 当一个函数的参数是由指针、整数和浮点数混合组成时，指针和整数通过通用寄存器传递，而浮点值通过XMM寄存器传递
```c
double fun1(int x, double y, long z);
// x 由寄存器%edi传递
// y 由寄存器%mm0传递
// z 由寄存器%rsi传递
// 返回值由%xmm0返回
```

#### 3.11.3 浮点运算操作
#### 3.11.4 定义和使用浮点常数
* AVX 浮点操作不能以立即数值作为操作数

#### 3.11.5 在浮点代码中使用位级操作
#### 3.11.6 浮点比较操作
* 浮点比较指令会设置三个条件码：ZF（零）、CF（进位）、PF（奇偶）

#### 3.11.7 对浮点代码的观察结论
### 3.12 小结

## 第4章 处理器体系结构
* 一个处理器支持的指令和指令的字节级编码称为它的指令集体系结构（ISA, Instruction-Set Architecture）
* 本章介绍硬件（CPU）设计
* CISC（读 sisk）, 复杂指令集
> 指令很多，Intel描述全套指令的文档有1200多页

> 编码是可变长度的，在x86-64上指令长度是1～15字节

> 有条件码

* RISC（读 risk），精简指令集
> 指令数少，通常少于100个

> 编码固定长度（8个字节？）

> 没有条件码 

* ARM体系结构是由英国公司Acorn Computers Ltd.提出，ARM最开始是Acorn RISC Machine的首字母缩写

* 实现一个数字系统需要三个组成部分：
> 计算对位进行操作的组合逻辑

> 存储位的存储单元

> 控制存储器单元更新的时钟信号

* 组合电路不存储任何信息，它只响应输入信号并产生相应的输出

* 寄存器文件不是组合电路，因为它有内部存储

* 处理一条指令可分成以下六个阶段（处理器无限循环执行这些阶段） 
> 取指

> 译码

> 执行

> 访存

> 写回

> 更新PC

* 流水线，提高系统吞吐量，但会增加延迟

* 流水线的局限
> 不一致划分

> 流水线过深收益下降

> 带反馈的流水线

* 流水线冒险
> 数据冒险(用暂停、转发避免数据冒险)

> 控制冒险

* 异常处理
> 三种内部异常：halt指令、有非法指令和功能码组合的指令、取指或数据读写试图访问一个非法地址

> 流水线中最深的指令引起的异常优先级最高

## 第5章 优化程序性能
* 编写高效程序需要做到以下三点 
> 第一、必须选择一组适当的算法和数据结构

> 第二、源码必须能被编译器有效转化成高效可执行代码

> 第三、拆分任务成多个部分，这些部分可在多核和多处理器的某种组合上并行执行

* 更高阶的优化性能，利用处理器的指令级并行能力，同时执行多条指令

### 5.1 优化编译器的能力和局限性
* 两个指针可能指向同一个内存位置的情况称为内存别名(memory aliasing)
```c
x = 1000;
y = 3000;
*q = y;
*p = x;
t1 = *q;
// t1的计算值依赖于指针p和q是否指向内存中同一个位置，如果不是则t1=3000;如果是，则t1=1000;
```
* GCC选项 -finline表示进行内联函数优化

* 用“内联函数替换”优化函数调用
> 如果使用编译器实现这种优化，编译器会改变原来的C语言代码，那么无法使用GDB调试原来的这段代码，因为它已经被改的面目全非
```c
long counter = 0;
// 原来的样子 
long f()
{
	return counter++;
}

long func1()
{
	return f() + f() + f() + f();
}
/////////////////////////////////////////////////////////
// 内联函数替换优化后的样子
long func1in()
{
	long t	 = counter++; // t=0, counter = 0
	t	+= counter++; // t=0 + 1 = 1, counter = 1
	t	+= counter++; // t=1 + 2 = 3, counter = 2
	t	+= counter++; // t=3 + 3 = 6, counter = 3
	return t;
}

long func1opt()
{
	long t = 4 * counter + 6;
	counter += 4;
	return t;
}
```

### 5.2 表示程序性能
* CPE（Cycles Per Element）每元素的周期数
> 用于度量执行重复计算的程序

* 处理器活动的顺序是由时钟控制的，时钟提供了某个频率的规律信号，通常用GHz表示
> 例如，一个系统有4GHz处理器，这表示处理器时钟运行频率为每秒4＊10^9个周期, 一个周期为0.25纳秒或250皮秒

### 5.3 程序示例
```c
// 加法操作
#define IDENT 0
#define OP +

// 乘法操作
#define IDENT 1
#define OP *

void combine1(vec_ptr v, data_t *dest)
{
	long i;
	*dest = IDENT;
	for (i = 0; i < vec_length(v); i++){
		data_t val;
		get_vec_element(v, i, &val);
		*dest = *dest OP val;
	}
}
```
### 5.4 消除循环的低效率
* 代码移动
```c
void func(vec_ptr v, long *dest)
{
	int i;

	// 原始代码
	for (i = 0;i < vec_length(A);i++)
		*dest = *dest OP v[i];
	
	// 代码移动后
	int i;
	long length = vec_length(A);
	
	for (i = 0;i < length;i++)
		*dest = *dest OP v[i];
}
```
### 5.5 减少过程调用
* 过程调用会带来开销，且妨碍大多数程序优化
* 分析循环体内的过程调用是否是必要的，如果只是一些读取下次循环的数组元素的，则完全可以将该过程展开 
* 减少过程调用同样需要修改C语言代码

### 5.6 消除不必要的内存引用
* 举例如下
```c
// 使用内存引用的
void func(long *A, long *B)
{
	int i;
	long length = get_length(A);// get_length是伪函数
	for (i = 0;i < length;i++)
		*B += A[i];
}

// 无内存引用的
void funcN(long *A, long *B)
{
	int i;
	long length = get_length(A);
	long acc = 0;

	for (i = 0;i < length;i++)
		acc += A[i];

	*B = acc;
}
```
### 5.7 理解现代处理器
* 延迟界限
> 当多个指令必须按照严格顺序执行时，就会遇到延迟界限

* 吞吐量界限
> 处理器功能单元（组成执行单元的东西）的原始设计能力，它是程序性能的上限

#### 5.7.1 整体操作
* 乱序执行，表示指令执行的顺序不一定要与它们在机器级程序中的顺序一致

* 现代微处理器有两个主要部分组成：指令控制单元（ICU，Instruction Control Unit）、执行单元（EU，Execution Unit）

* ICU负责从内存中读出指令序列，并根据这些指令序列生成一组针对程序数据的基本操作

* EU执行ICU生成的基本操作
> 执行单元中的功能单元由分支、算术运算、加载（load）、存储（store）组成

* Intel Core i7 Haswell有8个功能单元, 如下所示（用序号0～7表示）
> 0: 整数运算、浮点乘、整数和浮点数除法、分支

> 1: 整数运算、浮点加、整数乘、浮点乘

> 2: 加载、地址计算

> 3: 加载、地址计算

> 4: 存储

> 5: 整数运算

> 6: 整数运算、分支

> 7: 存储、地址计算

#### 5.7.2 功能单元的性能
* 延迟表明执行实际运算所需要的时钟周期总数
* 发射时间表示两次运算之间间隔的最小周期数
* 容量表示同时能发射多少个这样的操作

#### 5.7.3 处理器操作的抽象模型
### 5.8 循环展开
* 循环展开是一种程序变换，通过增加每次迭代计算的元素数量来减少循环的迭代次数
* 编译器可以很容易的执行循环展开，用优化等级3或更高等级调用GCC，它就会执行循环展开

### 5.9 提高并行性
#### 5.9.1 多个累积变量
* 保持执行操作的所有功能单元的流水线都是满的，程序才能达到这个操作的吞吐量界限
* 循环展开变换可能会改变原始函数的功能. 大多数编译器不会尝试对浮点数代码进行这种变换，因其不能判断这种改变程序行为的转换所带来的风险
* 多个累积变量，是要改变C语言代码来优化的，举例如下
```c
// 原来的
long acc = 0;
for(i = 0;i < count; i++)
	acc += A[i];

return acc;

///////////////////////////////////////////////////////////
// 多个累积变量的
long acc1 = 0;
long acc2 = 0;
long acc  = 0;

for(i = 0;i < count - 1;i += 2) // 拆分成一次处理两个累计值
{
	acc1 += A[i];
	acc2 += A[i + 1];
}

for(;i < count;i++)
	acc1 += A[i];

acc = acc1 + acc2;
return acc;

```

#### 5.9.2 重新结合变换
* 改变累积值与其他元素的合并顺序
* 对于整数加法、乘法这类运算是可结合的，这种重新改变变换顺序对结果没有影响
* 对于浮点数必须评估这种重新结合是否有可能严重影响结果
* 重新结合变换能够减少计算中关键路径上操作的数量
* 通常情况下，循环展开和并行地累积在多个值中，是提高程序性能的更可靠的方法
* 重新结合是要改动C语言源码的，举例如下
```c
// 原来的
A = (A * a) * (b * c);
// 重新结合变换后的
A = A * (a * (b * c));
```

### 5.10 优化合并代码的结果小结
### 5.11 一些限制因素
#### 5.11.1 寄存器溢出
* 循环并行个数超过了寄存器数量时，超出的部分需要用栈来保存，这叫寄存器溢出 
> 简单的说，就是循环中的累积变量acc1～accN，当N值大于寄存器数量时，这些acc就有一部分需要在栈中保存（即，内存中），这会降低性能

#### 5.11.2 分支预测和预测错误处罚
* 不要过分关心可预测的分支
> 处理器能够预测分支结果的，这类分支不会对形成程序执行中关键路径的指令的取指和处理产生太大的影响

* 书写适合用条件传递实现的代码
> 对于本质上无法预测的情况，如果编译器能够产生使用条件数据传送而不是使用条件控制转移的代码，可极大提高程序性能

```c
// 在随机数据上测试函数minmax，得到的CPE大约为13.50，而对于可预测数据，CPE为2.5～3.5，其预测错误惩罚为20个周期
void minmax(long a[], long b[], long n)
{
	long i;
	for (i = 0;i < n; i++){
		if (a[i] > b[i]){
			long t = a[i];
			a[i] = b[i];
			b[i] = t;
		}
	}

}
//

// 对函数minmax2的测试表示无论数据是任意的还是可预测的，CPE都大约为4.0。经确认其汇编代码中使用了条件传送
void minmax2(long a[], long b[], long n)
{
	long i;
	for (i = 0; i < n; i++){
		long min = a[i] < b[i] ? a[i] : b[i];
		long max = a[i] < b[i] ? b[i] : a[i];
		a[i] = min;
		b[i] = max;
	}
}
```

### 5.12 理解内存性能
* 练习题5.12 重写psum1的代码，使之不需要反复地从内存中读取p[i]的值。不需要使用循环展开。得到的代码测试出的CPE等于3.00，受浮点加法延迟的限制。
```c
// 我的实现
void psum1_myself(float a[], float p[], long n)
{
	long i;
	float v = p[0] = a[0];

	for (i = 1;i < n; i++){
		v += a[i];
		p[i] = v;
	}
}

// 答案给的实现
void psum1_answer(float a[], float p[], long n)
{
	long i;
	float v_last = p[0] = a[0];
	float v;

	for (i = 1;i < n;i++){
		v = v_last + a[i];
		p[i] = v;
		v_last = v;
	}
}

// 对比这两个实现的汇编中循环部分代码，可知，都没有读p[i]的命令，所以结论是CPE相同
// .L3 是psum1_myself对应的汇编循环部分代码
	.L3:                                                                                                                                             
       		movq    -8(%rbp), %rax
         	leaq    0(,%rax,4), %rdx
           	movq    -24(%rbp), %rax         // a++
		addq    %rdx, %rax
		movss   (%rax), %xmm0           // %xmm0 = a[i]
		movss   -12(%rbp), %xmm1        // %xmm1 = v
		addss   %xmm1, %xmm0            // %xmm0 = a[i] + v
		movss   %xmm0, -12(%rbp)        // v = %xmm0
		movq    -8(%rbp), %rax
		leaq    0(,%rax,4), %rdx
		movq    -32(%rbp), %rax         // 
		addq    %rax, %rdx              // p++
		movl    -12(%rbp), %eax         // 
		movl    %eax, (%rdx)            // p[i+1]= v
		addq    $1, -8(%rbp)            // i++


// .L6 是psum1_answer对应的汇编循环部分代码
	.L6:
		movq    -8(%rbp), %rax
		leaq    0(,%rax,4), %rdx
		movq    -24(%rbp), %rax
		addq    %rdx, %rax              // a++
		movss   (%rax), %xmm0           // %xmm0 = a[i]
		addss   -12(%rbp), %xmm0        // %xmm0 = a[i] + v_last
		movss   %xmm0, -16(%rbp)        // v = %xmm0
		movq    -8(%rbp), %rax
		leaq    0(,%rax,4), %rdx
		movq    -32(%rbp), %rax         // %rax = &p[0] 
		addq    %rax, %rdx              // p++
		movl    -16(%rbp), %eax         // 
		movl    %eax, (%rdx)            //p[i+1]=v;
		movl    -16(%rbp), %eax
		movl    %eax, -12(%rbp)         // v_last = v;
		addq    $1, -8(%rbp)            // i++
```

### 5.13 应用：性能提高技术 
### 5.14 确认和削除性能瓶颈
#### 5.14.1 程序剖析
#### 5.14.2 使用新程序来指导优化

### 5.15 小结
#### 代码剖析工具
* valgrind, 是一个工具集
> yum install valgrind

> valgrind --tool=memcheck --leak-check=full ./uniontestpg

* gprof
> centos 7自带

> gprof ./uniontestpg

* vtune
> Intel的VTUNE程序开发系统，用yum search all vtune未搜到

> 网上搜索了一下，需要付费，工具比较大，带界面的

## 第6章 存储器层次结构
* 程序需要的数据存储在CPU的寄存器中，那么指令执行期间，在0个周期内就能访问到数据
* 程序需要的数据存储在高速缓存中，需要4～75个周期
* 程序需要的数据存储在主存中，需要上百个周期
* 程序需要的数据存储在磁盘上，需要大约几千万个周期

### 6.1 存储技术
#### 6.1.1 随机访问存储器
* 随机访问存储器（Random Access Memory, RAM）分为两种，SRAM和DRAM
* SRAM（静态），用来作高速缓存存储器，即可以在CPU芯片上，也可以在片下
> SARM将每个位存储在一个双稳态的存储器单元里。每个单元是用六个晶体管电路实现的，这个电路可以无限地保持在两个不同的电压状态之一

> 只要有电，SRAM就会永远保持它的值

* DRAM（动态），用来作为主存以及图形系统的帧缓冲区
> DRAM将每个位存储为对一个电容的充电，每个单元由一个电容和一个访问晶体管组成

> DRAM易受光电干扰，被干扰后不会恢复

> DRAM单元在10～100毫秒内易失去电荷，因计算机运行时钟周期是纳秒级的，所以可以在DRAM内容失效内通过刷新内存的方式来保持DRAM中的数据

> 内存系统必须周期性地通过读出，然后重新写来刷新内存每一位

> DRAM芯片中的单元被分成d个超单元，每个超单元由w个DRAM单元组成。一个d*w的DRAM总共存储了dw位信息

> 超单元被组织成一个r行c列的长方形，这里有d=rc

> 每个DRAM芯片被连接到内存控制器电路，这个电路一交传送w位到每个DRAM芯片或一次从每个DRAM芯片传出w位

> 电路设计者将DRAM组织成二维陈列而不是线性数组是为了降低芯片上的地址引脚数量

* 举例说明从16*8的DRAM中读取超单元(2,1)的过程如下
> 第一步，内存控制器发送行地址2，DRAM的响应是将行2的整个内容都复制到一个内部缓冲区 

> 第二步，内存控制器发送列地址1，DRAM的响应是从行缓冲我复制出超单元（2，1）中的8位，并把它们发送到内存控制器

* 内存芯片封装在内存模块中，它插到主板的扩展槽上
> Core i7系统使用的240个引脚的双列直插内存模块，它以64位为单位传送数据到内存控制器和从内存控制器传出数据

* 传统的DRAM将超单元的一整行复制到它的内部行缓冲区中，使用一个，然后丢弃剩余的

* 增强的DRAM
> FPM DRAM（快页模式DRAM），允许对同一行连续地访问可以直接从行缓冲我得到服务。异步的。

> EDO DRAM（扩展数据输出DRAM）。异步的。

> SDRAM（同步DRAM），比异步的存储器更快输出它的超单元内容

> DDR SDRAM（双倍数据速率同步DRAM），是对SDRAM的增强，它通过使用两个时钟沿作为控制信号，从而使DRAM的速度翻倍

> DDR(2位）、DDR2（4位）、DDR3（8位）括号中的2位、4位、8位指的是有效带宽的预取缓冲区大小

> VRAM（视频RAM）

* 2010年之前，大多数服务器和桌面系统都是用DDR3 SDRAM构造的

* Intel Core i7只支持DDR3 SDRAM

* SDRAM最早出现在1995年的高端系统中，到2002年，大多数PC都是用SDRAM和DDR SDRAM制造的   

##### 如果断电，DRAM和SRAM会丢失它们的信息，它们都是易失的

##### 非易失性存储器即使在关电后，仍然保存着它们的信息 
* ROM（Read Only Memory，只读存储器）
> 存储在ROM设备中的程序被称为固件（firmware），当一个计算机系统上电后，它会运行存储在ROM中的固件（如，PC的BIOS）

* PROM（可编程ROM），只能被编程一次

* EPROM（可擦写可编程ROM），可擦写次数1000次

* EEPROM（电子可擦除可编程ROM），写擦写次数达10^5次

* 闪存





















