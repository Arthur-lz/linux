## 体系

### 机器语言01、汇编语言、C语言

#### 扫盲rsp, edi, eax
* 这些是CPU中寄存器的名字
##### 指令寄存器
* 它们主要用于访问堆栈内的存储单元，并且规定：

（1）BP为基指针(BasePointer)寄存器，用它可直接存取堆栈中的数据；
（2）SP为堆栈指针(StackPointer)寄存器，用它只可访问栈顶。
* 寄存器RBP、RSP和EBP、ESP和BP、SP称分别为64位、32位、16位指针寄存器(PointerRegister)

##### 变址寄存器
* 它们可作一般的存储器指针使用。在字符串操作指令的执行过程中，对它们有特定的要求，而且还具有特殊的功能。
* 寄存器RSI、RDI和ESI、EDI和SI、DI分别称为64位、32位、16位变址寄存器(Index Register)。

##### 数据寄存器
* 主要用来保存操作数和运算结果等信息，从而节省读取操作数所需占用总线和访问存储器的时间。
* RAX、RBX、RCX、RDX和EAX、EBX、ECX、EDX以及AX、BX、CX、DX分别称为64位、32位、16位数据寄存器(通用寄存器)。

##### 寄存器基本概念 
* 在中央处理器的控制部件中，包含的寄存器有指令寄存器(IR)和程序计数器(PC)。
* 在中央处理器的算术及逻辑部件中，包含的寄存器有累加器(ACC)。

#### 汇编
* 汇编的编译解释与具体的体系结构相关，如，在x86平台上，CPU是Intel的，那么需要用到Intel开发人员手册，里面有关于汇编助记符的定义，
  如subq, addq, movl等

> 为什么与体系结构相关? 首先要明白，汇编器的作用是将汇编程序翻译成机器码，机器码与具体的CPU相关，只有正确的芯片才可以识别出。

### DMA
   外设（如磁盘）与主存建立映射，CPU告诉DMA需要传多少数据，只有当将所需数据全部由外设传递到主存后才通知CPU，而不是每读一部分数据（如一个字节）就通知一下CPU							 

### ulimit -s 查看linux进程默认栈大小, 结果的单位是kB;
   也可以用ulimit -a查询所有资源限制，结果中包含了单位   

### 使用int32_t等数据类型宏定义来支持程序的可移植性   
    这样就不会因为从32位机切到64位机时出现数据类型对应到不同的位长度问题

## 第1章
### 1.1 信息就是位 + 上下文
* 系统中所有的信息都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据时的上下文。    
* C语言是设计用来实现Unix操作系统的.

### 1.2 程序被其他程序翻译成不同格式
* 编译系统
hello.c->预处理->hello.i(修改了的源程序，还是文本) 
	     ->编译器(cc)->hello.s（汇编程序，还是文本）
	         ->汇编器(as)->hello.o （可重定位的目标程序，已经变成二进制文件）
		     ->链接器(ld)->hello.out（可执行的目标程序，二进制文件）

* 预处理，根据源文件中以字符#开头的命令修改原始的C程序。

* 编译器，将.i文件翻译成文件文件.s，它是一个包含汇编语言的程序。

* 汇编器，将.s文件翻译成机器语言指令，并把结果保存在二进制.o文件中。

* 链接器，将源程序中依赖的目标文件合并到可执行目标文件。

### 1.3 了解编译系统如何工作是大有益处的
### 1.4 处理器读并解释存储在内存中的指令
#### 1.4.1 系统的硬件组成 
#### 1.4.2 运行hello程序
* 见目录deepincomputerlab/code/intro/目录中的几个图片说明了hello从终端输入到运行结束全过程.
### 1.5 高速缓存至关重要
* 解决CPU与主存之间速度差过大（100倍左右）而引入高缓。
### 1.6 存储设备形成层次结构
* 见目录deepincomputerlab中的png
### 1.7 操作系统管理硬件
* 操作系统有两个功能
> 防止硬件被失控的应用程序滥用

> 向应用程序提供简单一致的机制来控制复杂又不相同的低层硬件设备

* 操作系统通过三个抽象来实现上面的两个功能，即虚拟内存、进程、文件
> 文件是对I/O设备的抽象

> 虚拟内存是对主存和磁盘I/O设备的抽象

> 进程是对CPU、主存、I/O设备的抽象

#### 1.7.1 进程
* 在一个系统上可以同时运行多个进程, 
* 并发运行，指一个进程的指令和另一个进程的指令是交错执行的, 这是通过处理器在进程间切换实现的, 这种机制称为上下文切换。
* 操作系统会保存进程运行所需的所有状态信息, 这种状态就是上下文，包括：PC(程序计数器)、寄存器中的值，主存的内容等。
* 在任何一个时刻，单核处理器只能运行一个进程的代码
* 当操作系统决定把控制权从当前进程转移到某个新进程时，就会进行上下文切换。即，保存当前进程上下文，恢复新进程上下文，然后将控制权转移到新进程，新进程就会从它上次停止的地方开始执行。

* 内核不是一个独立的进程，它是什么呢？内核是操作系统管理全部进程所需要的代码和数据结构的集合。

#### 1.7.2 线程
* 线程运行在进程上下文
* 线程间共享数据更方便简单
* 多线程可提高性能，当然你的应用程序必须要使用多线程才可以

#### 1.7.3 虚拟内存 
* 它提供了一种假象，即，每个进程都是独占的使用内存
* 每个进程看到的内存都是相同的, 称为虚拟地址空间

#### 1.7.4 文件 
* 文件就是字节序列

### 1.8 系统之间利用网络来通信 
### 1.9 重要主题
#### 1.9.1 Amdahl 定律(阿姆达尔定律)
* 用于分析计算系统性能的定律
* S = Told / Tnew
* S = 1/((1 - a) + a/k)

#### 1.9.2 并发和并行
* 线程级并发
> 多核处理器结构，L1，L2在每一个核的内部，L3在核的外部CPU内部是所有核共享的一块高速缓存

> 多核处理器可以从两方面提高系统性能，1是减少使用并发，2是提高应用程序速度（当然应用程序必须以多线程方式编写，这些线程可以并行执行）

> 线程级并发我的理解与进程并发原理相同，比如，一个线程必须要等到数据加载到L1高速缓存中，那么此时CPU就可以去执行另外一个线程。

* 指令级并行
> 指令流水线, 将一条指令拆分成不同的步骤，将处理器的硬件组织成一系统阶段，每个阶段执行一个步骤，这些阶段并行的执行，用来处理不同指令的不同部分。

* 单指令多数据并行(SIMD) 

#### 1.9.3 计算机系统中抽象的重要性 
* 指令集架构是对实际处理器硬件的抽象，这样机器代码表现得好像运行在一个一次只执行一条指令的处理器上一样。

### 1.10 小结
* 计算机系统是硬件和系统软件组成的，它们共同协作让应用程序可以运行。

## 第二章 信息的表示和处理 
* 学习目标？
> 数据类型是如何表示的?

> 硬件是如何实现的？如，CPU是如何实现的？这些硬件是如何被用来执行指令的？

> 程序是如何表示的? 如何执行的?

* 二进制数－－－数字革命的基础
> 在构造存储和处理信息的机器时，二进制工作得更好。二进制可以很容易被表示，如：电平的高低、磁的两极、打孔机的孔。

* 程序员需要对计算机运算与人类熟悉的整数和实数运算之间的关系有清晰的理解

* C的几个不同版本 
> GNU 89, GCC命令行无配置选项时，或-std=gnu89时，使用GNU 89版本的C语言进行编译

> ANSI C, ISO C90, GCC命令行选项使用-ansi, 或 -std=c89时，使用

> ISO C99, GCC命令行使用选项 -std=c99

> ISO C11, GCC命令行使用选项 -std=c11

### 2.1 信息存储
* C语言中，一个指针的值，无论它指向什么数据结构（整数、结构或某个其他程序对象），它都是某个存储块第一个字节的虚拟地址。

* 大概理解了，为什么为有虚拟地址空间这个概念，因为要统一程序自身的差异，这样编译器和运行时系统才可以知道如何用内存来存放不同的程序对象。

* C编译器维护指针类型，但它编译出来的机器指令中没有数据类型相关信息。其实是这样，数据类型是告诉程序需要从指针所指的地址处读多长的数据，
  如int *p; int表示指针p所指向的地址处有四个字节的数据是有效的，在p++时，指针p会移动四个字节；而前面说的四个字节是由数据类型int而得到的。

#### 2.1.1 十六进制表示法  
* 10进制数转16进进制方法
> 举例说明：10进制数188转成16进制
  188 = 11 * 16 + 12   ---> C
  11 = 0 * 16 + 11     ---> B
  所以，十进制数188对应的十六进制数为0xBC
> 这里需要注意的是第一，下次等号左面的数是上一个等式中乘16的那个数
                  第二，最后一个等式的余数是十六进制数的最高位

* 16进制转10进制方法
> 举例说明: 16进制数0x3C转换成10进制数x
  x = 3 * (16 * 1) + 12 * (16 * 0) = 60
                |               |
            16的一次方       16的0次方
                
* 16进制转2进制方法
> 举例说明: 16进制数0x12转换成2进制数x
  x = 0001 0010
       |    |
       1    2

#### 2.1.2 字数据大小
* 每台计算机都有一个字长，指明指针数据的标称大小。虚拟地址是以这样一个字来编码的。

|C声明||字节数|字节数|
|:-|:-|:-|:-|
|有符号|无符号|32位|64位|
|char|unsigned char|1|1|
|short|unsigned short|2|2|
|int|unsigned|4|4|
|long|unsigned long|4|8|
|int32_t|uint32_t|4|4|
|int64_t|uint64_t|8|8|
|char*||4|8|
|float||4|4|
|double||8|8|

> int32_t, int64_t是ISO C99引入的，这种类型长度固定，不会因为编译器和机器设置而变化。
 
* 下面这几个不同的声明表达的意思相同
> unsigned long

> unsigned long int

> long unsigned

> long unsigned int

即关键字顺序不唯一哈

* C语言标准对不同数据类型的数字范围设置了下界，但是没有设置上界
>  没上界，在程序从32位迁移到64位机时可能会出现问题

#### 2.1.3 寻址和字节顺序
* 多字节对象，必须明确两点：
> 对象地址

> 在内存中如何排列这些字节

* 在几乎所有机器上，多字节对象都被存储为连续的字节序列，对象的地址是字节序列中最小的地址。
> 举例说明, int x; 

> 这里假设变量x的地址为0x100，也就是说&x = 0x100，那x的四个字节将被存储在内存的0x100, 0x101, 0x102, 0x103四个地址上。

* 大小端序
> 机器选择将最低有效字节放在最左面－－－小端序

> 机器选择将最高有效字节放在最左面－－－大端序

> 大多数Intel兼容的机器使用小端序

> 较新的微处理器支持双端模式，即可以配置成大端或小端，但是在选择了特定的操作系统之后，那么字节序也同时固定了，如ARM本身支持双端模式，
  但常用的Android或iOS操作系统只能使用小端字节序。

* Intel处理器机器代码文本（其由反汇编器生成）举例：
```as
4004d3: 01 05 43 0b 20 00	add	%eax,0x200b43(%rip)
```
> 首先Intel处理器字节序是小端序

> 其次十六进制字节串01 05 43 0b 20 00是一条指令的字节级表示, 它与add	%eax,0x200b43(%rip)等价

> 取出这条指令字节序列中后四个字节43 0b 20 00，将其反序排列00 20 0b 43，得到值0x00200b43，即0x200b43，这与汇编指令表示中的数值相等。 

* 字节序的另一个应用：强制类型转换或联合，它允许以另外一种数据类型T来引用数据对象，而T与数据对象创建时使用的数据类型t不同。

* man ascii, 查看ascii字符码表

* 看下面这道题
``` c
int x = 0x87654321;
unsigned char* c1 = &x;  
unsigned short * s2 = &x;
// c1, s2的大小端值是什么？
/* 大端
   地址：1   2   3   4
     值：87  65  43  21

   小端
   地址：1   2   3   4
     值：21  43  65  87

     *c1大端值等于87;
     *c1小端值等于21;

     *s2大端值等于87 65;
     *s2小端值等于21 43;

     这里需要明确变量的地址是怎么定义的，指针c1, s2的地址是其所指向字节序列中第一个字节的地址，即最左面的那个字节对应的地址。
     以变量x来说明，大端字节序时，c1的地址就是87的地址，s2的地址也是87；小端序时，c1的地址是21的地址，s2的地址与c1相同，都是指向&x;
   
   */

```
#### 2.1.4 表示字符串
* 在使用ASCII码作为字符码的任何系统上，其值与字节序无关。即，在大端或小端机器上输出任意字符串（如"12345"）得到的结果都是相同的（31 32 33 34 35）
> 因此，文本字符串类型的数据比二进制数据在平台移植上更占优势。

* strlen，它不计算字符串中终止的空字符null，所以strlen("12345")=5，而实际上"12345"的长度是6，因为还有一个\0

* 二进制代码很少能在不同机器和操作系统组合之间移植
> 从机器的角来看，程序仅仅是字节序列。机器没有关于原始源程序的任何信息。

* UTF-8是变长编码的，所有ASCII字节序列用ASCII码表示和用UTF-8码表示是一样的 

* Unicode是定长4字节编码的

#### 2.1.6 布尔代数简介
* TRUE, FALSE------> 1, 0

* 与运算&, 或运算|, 异或运算^
> 1 & 1 = 1;  1 & 0 = 0;  0 & 0 = 0;

> 1 | 1 = 1;  1 | 0 = 1;  0 | 0 = 0;

> 1 ^ 1 = 0; 1 ^ 0 = 1; 0 ^ 0 = 0;

#### 2.1.7 C语言中的位级运算
* 位级运算常用于实现掩码运算, 表示从一个字中选出的位的集合
> 举例说明，掩码0xFF表示取一个字的低8位，如x&0xFF, x = 0x89ABCDEF, 那么x & 0xFF = 0xEF

* ~0将生成一个全1的掩码，对于32位机器可以写成0xFFFF FFFF，但这样的代码是不能移植的

* 练习题2.12对于下面的值，写出变量x的C语言表达式。你的代码应该对任何字长w>=8都能工作。我们给出了当x=0x87654321以及w=32时表达式求值的结果，
仅供参考。
>A. x的最低有效字节，其他位均设置为0。 [0x00000021]。
```c
// 作答如下
  x = x & 0xFF; // 因为值以十六进制表示时两个十六进制数表示一字节，所以掩码为0xFF
```

>B. 除了x的最低有效字节外，其他的位都取补，最低有效字节保持不变。[0x789ABC21]。
```c
// 作答如下
x = x^~0xFF;

```

>C. x的最低有效字节设置成全1，其他字节都保持不变。[0x876543FF]
```c
// 作答如下
x = x|0xFF;

```
* 异或运算x^y = (x&~y)|(~x&y)

#### 2.1.8 C语言中的逻辑运算	
* 逻辑与运算&&
* 逻辑或||
* 逻辑非!
> 不要将逻辑运算与位运算混淆

* 练习题2.15只使用位级和逻辑运算，编写一个C语言表达式，它等价于 x==y。
```
答：
当且仅当x的每一位和y相应的每一位匹配时，x^y等于0。然后我们用!来判断一个字是否包含任何非0位。

```
#### 2.1.9 C语言中的移位运算
* 左移<<，如0x87654321 << 4 = 0x76543210, 这就表示把数据向左移动4位，把原值最左面4位删除，同时把原值最右面4位用0补上。
* 右移>>，机器一般支持两种右移，逻辑右移和算术右移。
> 几乎所有的编译器和机器组合都对有符号数使用算术右移，而对无符号数采用逻辑右移。

* 位移量如果超出了数值实际长度，则对位移量取模做为位移量，举例如下 
```c
int v1 = 0xFEDCBA98 << 32;
int v2 = 0xFEDCBA98 >> 36;
unsigned v3 = 0xFEDCBA98u >> 40;

/* v1 左移32位，而其是int 类型，长度为4字节，正好32位，那么它实际上移动的位数是0，即32 mod 32 = 0;
   v2 右移36位，同要是int类型，数据长度为32位，所以36 mod 32 = 4, 所以其实际移动的位移量是4;
   v3 右移40位，是无符号的int类型，数据长度为32位，所以 40 mod 32 = 8, 所以其实际移动的位移量是8；
 */
```

* 在C语言中，加法、减法的优先级比移位运算高
```c
  1<<2+3<<4 = 1 << (2 + 3) << 4 = 512 // 2^9
```

### 2.2 整数表示
#### 2.2.1 整型数据类型
#### 2.2.2 无符号数的编码
#### 2.2.3 补码编码
* 有符号数最常见的表示方式是补码 
* 补码的计算举例
```asm
  //二进制值0001 = -0 * 2^3 + 0 * 2^2 + 0 * 2^1 + 0 * 2^0 = 0 + 0 + 0 + 1 = 1;
  //二进制值0101 = -0 * 2^3 + 1 * 2^2 + 0 * 2^1 + 1 * 2^0 = 0 + 4 + 0 + 1 = 5;
  //二进制值1011 = -1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 * 2^0 = -8 + 0 + 2 + 1 = -5;
  //二进制值1111 = -1 * 2^3 + 1 * 2^2 + 1 * 2^1 + 1 * 2^0 = -8 + 4 + 2 + 1 = -1;

  //0x2e0对应二进制值为 0010 1110 0000 = 1 * 2^9 + 1 * 2^7 + 1 * 2^6 + 1 * 2^5 = 512 + 128 + 64 + 32 = 736; 
  //-0x58对应二进制值为 -(0101 1000) = -(1 * 2^6 + 1 * 2^4 + 1 * 2^3) = -(64 + 16 + 8) = -88;
  //-0x30对应二进制值为 -(0011 0000) = -(1 * 2^5 + 1 * 2^4) = -(32 + 16) = -48;
  //上面的值是由反汇编器生成的ASCII码形式的程序

  4004d0: 48 81 ec e0 02 00 00	sub	$0x2e0,%rsp
  4004d7: 48 8b 44 24 a8	mov 	-0x58(%rsp),%rax
  4004ec: 48 03 47 28		add	0x28(%rdi),%rax
  4004e0: 48 89 44 24 d0	mov	%rax,-0x30(%rsp)

```
#### 2.2.4 有符号数和无符号数之间的转换
* C语言允许在各种不同的数字数据类型之间做强制类型转换
* 对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：数值可能会变，但是各位对应的值保持不变
* 无符号数的最大值与有符号数的-1，这两者的位表示的内容是相同的

* 补码转换为无符号数
```
	假设有符号数x
	无符号数＝x + 2^w,	当x < 0时
	        ＝x，		当x >= 0时
```

* 无符号数转换为补码
```
	假设无符号数u
	补码＝u,		当u <= 有符号数最大值时
            ＝u - 2^w,		当u > 有符号数最大值时
```
#### 2.2.5 C语言中的有符号数与无符号数
* 通常，大多数数字都是有符号的
* 要创建一个无符号常量，必须加上后缀符'U'或者'u', 例如：12345U, 或者12345u
* C语言允许有符号数和无符号数之间的转换

* 当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制转换为无符号数，并假设这两个数都是非负的，之后再执行这个运算

#### 2.2.6 扩展一个数字的位表示
* 无符号数的0扩展
* 补码数的符号扩展
```c
short sx = -12345;		// 对应的十六进制值: cf c7
unsigned short usx = sx;        // 对应的十六进制值: cf c7
int x = sx;			// 对应的十六进制值: ff ff cf c7
unsigned ux = usx;		// 对应的十六进制值: 00 00 cf c7
```
* 练习题2.23
```c
int fun1(unsigned word)
{
	return (int)((word << 24) >> 24);
}

int fun2(unsigned word)
{
	return (((int) word << 24) >> 24);
}

```
|w|fun1(w)|fun2(w)|
|:-|:-|:-|
|0x00000076|0x00000076|0x00000076|
|0x87654321|0x00000021|0x00000021|
|0x000000c9|0x000000c9|0xffffffc9|
|0xEDCBA987|0x00000087|0xffffff87|

> 解题思路: 左移都是逻辑左移，右移分两种，一个逻辑右移，一个算术右移，有符号数是算术右移，而无符号数是逻辑右移。

> 解题思路：不必考虑在将无符号数强制转换为有符号数后w的值是正是负，而只需要考虑右移是什么右移。 

#### 2.2.7 截断数字
#### 2.2.8 关于有符号数与无符号数的建议
```c
float sum_elements(float a[], unsigned len)
{
	int i;
	float res = 0;

	for(i = 0; i <= len - 1; i++)
		res += a[i];
	return res;
}
/*
   当参数len=0时，运行这段代码应该返回0.0。但实际上，运行时会遇到内存错误。请解释为什么，并说明如何修改代码。
   答：
   len是无符号整型，那么当len = 0时 len - 1等价于0u - 1 = -1u = 0xFFFFFFFF;这是无符号值最大值
   那么for循环访问数组a时，将会出现越界访问，从而出现内存错误。

   修改代码的方法：
   将for循环中的终止条件修改为i < len;
   或者，将len 修改为int类型。
 
 */
```

* 无符号类型和有符号类型参数相互传递时，因为C语言中的隐式转换会让程序员写的程序出现不易发现的错误，建议统一参数类型以避免类似问题
 
### 2.3 整数运算
#### 2.3.1 无符号加法
* 无符号数加法溢出检测
```c
int uadd_ok(unsigned x, unsigned y)
{
	unsigned sum = x + y;
	return sum >= x;
}
```
#### 2.3.2 补码加法
* 做补码加法时，必须明确当结果太大（为正）或者太小（为负）时，应该做些什么
* x + y, x和y都是4位长的，那么当

```
 x + y >= 2^3时，正向溢出
 x + y < -2^3时，负向溢出
 /*
  * 这就是说补码加法原理是：
  * 1, x + y = x + y - 2^w, 2^(w-1) <= x + y --------------> 正溢出
  * 2, x + y = x + y,  -2^(w-1) <= x + y < 2^(w-1)
  * 3, x + y = x + y + 2^w, x + y < -2^(w-1)－－－－－－－－>负溢出
  * w 是参数x, y 的位长
  */
```
* 补码加法溢出检测
```c
int tadd_ok(int x, int y)
{
	int sum = x + y;
	int negover = x < 0 && y < 0 && sum >= 0;
	int plusover = x > 0 && y > 0 && sum <= 0;
	return !negover && !plusover;
}
```

|x|y|x + y|x + t5y|情况|
|:-|:-|:-|:-|:-|
|[10100]|[10001]|x = -1 * 2^4 + 1 * 2^2 = -12, y = -1 * 2^4 + 1 * 2^0 = -15, x + y = -12 -15= -27 < -2^4|-27+2^5=5|负溢出|
|[11000]|[11000]|x = -8, y = -8; x + y = -16;|-16|正常|
|[10111]|[01000]|x = -9; y = 8; x + y = -1;|-1|正常|
|[00010]|[00101]|x = 2; y = 5; x + y = 7;|7|正常|
|[01100]|[00100]|x = 12; y = 4; x + y = 16; 16 >= 2^4|16 - 2^5=-16|正溢出|

#### 2.3.3 补码的非
* 补码的非-twx = TMinw, x = TMinw;
          -twx = -x, 	x < TMinw;

* 在C语言中，对于任意整数值x, 计算表达式-x和~x+1得到的结果完全一样	  

* 根据x的补码表示，填写下表，确定x的加法逆元
|x的十六进制|x的十进制|x补码的非（十进制）|x补码的非(16进制)|
|:-|:-|:-|:-|
|0|0|0|0|
|5|5|-5|1011=0xB|
|8|8|-8|1000=0x8|
|D|-3|3|0011=0x3|
|F|-1|1|0001=0x1|

* 练习题2.34
|模式|x|y|x*y|截断的x*y|
|:-|:-|:-|:-|:-|
|无符号|[100]|[101]|4 * 5 = 20 [010100]|4 [100]|
|补码|[100]|[101]|-4 * (-3) = 12 [001100]|-4 [100]|
|无符号|[010]|[111]|2 * 7 = 14 [001110]|6 [110]|
|补码|[010]|[111]|2 * (-1) = -2 [000110]| -2 [110]|
|无符号|[110]|[110]|6 * 6 =36 [010100]| 4 [100]|
|补码|[110]|[110]|-2 * (-2) = 4 [000100]| -4[100]|

* 检测有符号数相乘是否产生溢出tmult_ok
```c
int tmult_ok(int x, int y)
{
	int p = x * y;
	return !x || p/x == y;
}
 // 可用于乘法溢出检测
```
#### 2.3.6 乘以常数
* 大多数机器上乘法指令相当慢，需要10个或更多时钟周期，然而其他整数运算（如，加法，减法，位级运算和移位）只需要1个时钟周期
> 因此，编译器使用了移位和加减法组合的形式来替换原来的乘以常数的运算。

```c
#define K = 14;
int x;

x * K;
// K是常数14, 14 = 2^3 + 2^2 + 2^1 = 8 + 4 + 2
x * K = (x << 3) + (x << 2) + (x << 1); // 这样就将一个乘以常数的运算变成了移位和加法运算。
```

#### 2.3.7 除以2的幂
* 在大多数机器上，整数除法比整数乘法更慢，需要30个时钟周期或更多
* 除以2的幂的运算可以用右移运算来实现
* 无符号和补码数分别使用逻辑移位和算术移位来实现

##### 除以2的幂的无符号除法
* 执行一个逻辑右移k位与除以2^k再舍入到零有一样的效果

##### 除以2的幂的补码除法，向下舍入
* 算术右移类似于除以2的幂，除法是向下舍入，而不是向零舍入

##### 除以2的幂的补码除法，向上舍入
* 右移之前加上一个偏量，结果就向零舍入了
> 这个适当的偏量是如何确定的？

##### 除以2的幂可以通过逻辑或算术右移来实现。但是，这种方法不能推广到除以任意常数

#### 2.3.8 关于整数运算的最后思考

### 2.4 浮点数 
* 浮点数表示对形如V = x * 2^y的有理数进行编码
* IEEE, 电气和电子工程师协会

#### 2.4.1 二进制小数
|二进制表示|值|十进制|
|:-|:-|:-|
|0.0|0/2|0.0|
|0.1|1/2|0.5|
|0.01|1/4|0.25|
|0.001|1/8|0.125|
|0.0001|1/16|0.0625|

* 假定只考虑有限长度的编码，那么十进制表示法不能准确表达像1/3，5/7这样的数
* 小数的二进制表示法只能表示那些能够被写成x * 2^y的数。其他的值只能够近似地表示
> 比如值1/10, 10是十进制数，它的二进制表达式是一个无穷序列0.000110011[0011]......

#### 2.4.2 IEEE浮点表示
* IEEE浮点标准V=(-1)^s * M * 2^E
> s符号，M是尾数(二进制小数，也称为小数域？)，E是阶码
* 单精度浮点格式中，s占一位，E占8位，M占23位
* 双精度浮点格式中，s占一位，E点11位，M占52位

* NaN表示Not a Number，不是一个数
* 偏置--->biased

##### 规格化的值
* 阶码的位中不全为0也不全为1
* E = e - Bias, 其中e是无符号数, Bias等于2^(阶码位数-1) - 1

##### 非规格化的值
* 阶码所有位都是0
* E = 1 - Bias

##### 特殊值 
* 阶码所有位全为1
* 当我们把两个非常大的数相乘，或者除以0时，无究能够表示溢出的结果

#### 2.4.3 数字示例

#### 2.4.4 舍入
* 因为浮点运算只有有限的范围和精度，所以浮点运算只能近似地表示实数运算

#### 2.4.5 浮点运算
* 浮点加法不具有结合性
* 浮点乘法在加法上不具有分配性

#### 2.4.6 C语言中的浮点数
* 当在int, float, double格式之间进制强制类型转换时，程序改变数值和位模式原则如下
> 从int转换成float, 数字不会溢出，但是可能舍入

> 从int或float转换成double时，因为double有更大的范围，也有更高的精度，所以能够保留精确的数值

> 从float或double转换成int，值会向0舍入。例如1.999会被转换成1；-1.999将被转换成-1。进一步来说，值可能会溢出。

* 将大的浮点数转换成整数是一种常见的程序错误来源

### 2.5 小结 
* 整数、实数、字符串分别有不同的编码方式来表示
* 大多数机器对整数使用补码编码
* 大多数机器对浮点数使用IEEE标准754编码
* 相同长度的无符号和有符号整数之间进行强制类型转换时，大多数C语言实现原则是位模式不变，即二进制位的值相同 
* 浮点运算只有有限的范围和精度，且不支持算术运算属性中的结合性

## 第三章 程序的机器级表示 
* 计算机执行机器代码
* 用高级语言写程序的最大优点是，可以在很多不同的机器上编译和执行，而汇编代码则只与特定的机器密切相关
* 精通细节是理解更深和更基本概念的先决条件
* x86-64是笔记本和台式机中最常见处理器的机器语言 
> 同时也是大型数据中心、超级计算机的最常见处理器的机器语言

> IA32是一种重要的机器语言

* AMD------> Advanced Micro Devices

### 3.1 历史观点
> Intel处理器，人称x86发展历史
* 8086（1978年, 29K个晶体管）
* 80286（1982年，134K个晶体管）
* i386（1985年，275K个晶体管）
* i486（1989年，1.2M个晶体管）
* Pentium（1993年，3.1M个晶体管）
* PentiumPro（1995年，5.5M个晶体管）
* Pentium/MMX（1997年，4.5M个晶体管）
* Pentium II（1997年，7M个晶体管）
* Pentium III（1999年，8.2M个晶体管）
* Pentium 4（2000年，42M个晶体管）
* Pentium 4E（2004年，125M个晶体管），增加了超线程；还增加了EM64T（实现64位扩展）
* Core 2（2006年，291M个晶体管），Intel的第一个多核处理器，不支持超线程 
* Core i7, Nehalem（2008年，781M个晶体管），同时支持多核和超线程
* Core i7, Sandy Bridge（2011年，1.17G个晶体管）
* Core i7, Haswell（2013年，1.4G个晶体管）

* Intel处理器系列有好几个名字，包括IA32（Intel Architecture 32-bit, Intel 32位体系结构） 
  Intel64，它是IA32的64位扩展，我们称为x86-64

### 3.2 程序编码
* gcc可以使用cc来启动
* gcc -Og -S hello.c与gcc -O1 -S hello.c中编译器优化选项-Og与-O1相同；-S表示只生成汇编代码；
* gcc 编译器优化等级越高性能越好，但对应更高的优化等级其产生的机器代码和源代码之间的关系越难以理解

#### 3.2.1机器级代码
* 机器语言编程有两种抽象  
> ISA（Instruction Set Architecture指令集架构）来定义机器级程序的格式和行为，它定义了处理器状态、指令格式，及每条指令对状态的影响
 
> 机器级程序使用的内存地址是虚拟地址，内存模型是一个非常大的字节数组

* x86-64的机器代码和原始的C语言代码差别非常大，一些通常对C语言程序员隐藏的处理器状态都是可见的：
> 程序计数器（通常称为PC，在x86-64中用%rip表示）给出将要执行的下一条指令在内存中的地址

> 整数寄存器，包含16个，每一个可存储64位的值。这些寄存器可以存储整数或地址（C语言的指针）。有些寄存器用于记录程序状态，有些用于临时保存数据，如函数的参数和局部变量，以及函数的返回值

> 条件码寄存器，用于保存最近执行的逻辑或算术运算指令的状态信息，它们用于实现控制或数据流中的条件变化，比如实现if或while语句

> 向量寄存器，可以存放一个或多个整数或浮点数值

* 在机器代码中无数据类型的定义，即不会区分C语言中的数据类型，其只是会使用一组连续的字节来表示

* 程序内存包含
> 程序的可执行机器代码

> 操作系统需要的一些信息 

> 用来管理过程调用和返回的运行时栈

> 用户分配的内存块

* 程序内存用虚拟地址来寻址

* 在任意给定时刻，只有有限的一部分虚拟地址是合法的

* 操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址

* 一条机器指令只执行一个非常基本的操作
> 例如，将存放在寄存器中的两个数字相加

> 例如，在储存器和寄存器之间传递数据

> 例如，条件分支转移到新的指令地址

> 编译器必须产生这些指令的序列，从而实现程序结构!!!!!!!!

#### 3.2.2 代码示例
* 机器执行的程序只是一个字节序列，它是对一系列指令的编码

* 机器对产生这些指令的源代码几乎一无所知

* 反汇编器
``` shell
$: objdump -d hello.o
hello.o：     文件格式 elf64-x86-64


Disassembly of section .text:

0000000000000000 <main>:
   0:   48 83 ec 08             sub    $0x8,%rsp
   4:   bf 00 00 00 00          mov    $0x0,%edi
   9:   e8 00 00 00 00          callq  e <main+0xe>
   e:   bf 00 00 00 00          mov    $0x0,%edi
  13:   e8 00 00 00 00          callq  18 <main+0x18>
  18:   b8 00 00 00 00          mov    $0x0,%eax
  1d:   48 83 c4 08             add    $0x8,%rsp
  21:   c3                      retq
```
> x86-64的指令长度从1到15个字节不等

> 设计指令格式的方式是，从某个给定的位置开始，可以将字节唯一地解码成机器指令, 例如，只有pushq %rbx是以字节值53开头

> 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码

> 反汇编器使用的指令命名规则与GCC生成的汇编代码使用的有些细微差别 

* 链接器的任务中包含为函数调用找到匹配的可执行代码位置

* 为了提高存储器系统性能，能更好的放置下一块代码块，链接器可能会在函数代码末尾增加nop(一个nop占一字节)指令来使函数代码长度变成16字节

#### 3.2.3 关于格式的注释
* ATT格式汇编代码, AT&T，它是运营贝尔实验式的公司
> ATT是GCC、objdump和其他一些我们使用的工具默认格式

* 与ATT格式对应的是Intel格式
``` shell
cc -Og -S -masm=intel hello.c

# 使用上面的参数gcc可以产生Intel格式的汇编代码

```
> 在Microsoft和Intel文档中的汇编使用的就是Intel格式的汇编

#### 3.3 数据格式
* 由于Intel是从16位体系结构扩展成32位的，Intel用术语“字（word）“来表示16位数据类型。称32位数为”双字（double words）”，称64位数为“四字（quad words）”

* C语言数据类型在x86-64中的大小
|C声明|Intel数据类型|汇编代码后缀|大小（字节）|
|:-|:-|:-|:-|
|char|字节|b|1|
|short|字|w|2|
|int|双字|l|4|
|long|四字|q|8|
|char*|四字|q|8|
|float|双字|s|4|
|double|四字|l|8|

* 大多数gcc生成的汇编代码指令都有一个字符的后缀，表明操作数的大小 
> 例如，数据传送指令有四个变种: 
```asm
	movb        // 传送字节
	movw        // 传送字
	movl        // 传送双字, 后缀l表示双字，因为32位数被看成是“长字（long word）”
	movq        // 传送四字

```
* 汇编代码与使用后缀l来表示4字节整数和8字节双精度浮点数，这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器

### 3.4 访问信息
* 整数寄存器, 所有16个寄存器的低位部分都可以作为字节、字（16位）、双字（32位）和四字（64位）数字来访问
|63~0|31~0|15~0|7~0|说明|
|:-|:-|:-|:-|:-|
|%rax|%eax|%ax|%al|返回值|
|%rbx|%ebx|%bx|%bl|被调用者保存|
|%rcx|%ecx|%cx|%cl|第4个参数|
|%rdx|%edx|%dx|%dl|第3个参数|
|%rsi|%esi|%si|%sil|第2个参数|
|%rdi|%edi|%di|%dil|第1个参数|
|%rbp|%ebp|%bp|%bpl|被调用者保存|
|%rsp|%esp|%sp|%spl|栈指针|
|%r8|%r8d|%r8w|%r8b|第5个参数|
|%r9|%r9d|%r9w|%r9b|第6个参数|
|%r10|%r10d|%r10w|%r10b|调用者保存|
|%r11|%r11d|%r11w|%r11b|调用者保存|
|%r12|%r12d|%r12w|%r12b|被调用者保存|
|%r13|%r13d|%r13w|%r13b|被调用者保存|
|%r14|%r14d|%r14w|%r14b|被调用者保存|
|%r15|%r15d|%r15w|%r15b|被调用者保存|

* 8086中有8个16位寄存器，即上图中的%ax~%sp
* IA32架构时，寄存器扩展成了32位寄存器，标号从%eax到%esp
* 到x86-64后，原来的8个寄存器扩展成64位，标号从%rax到%rsp；并且增加了8个新的寄存器从%r8到%r15

#### 3.4.1 操作数指示符
* x86-64支持三种操作数：立即数、寄存器、内存引用
* 大多数指令有一个或多个操作数，用来指出执行一个操作时需要使用的源数据值，以及放置结果的目的位置

* 立即数，在ATT格式汇编中，使用$后面跟一个用标准C表示法表示的整数，如$-577或$0x1F；不同的指令对应不同的立即数范围，汇编器会自动选择最紧凑的方式进行数值编码

* 寄存器，

* 内存引用，它会根据计算出来的地址（通常称为有效地址）访问某个内存位置

* 寻址模式

#### 3.4.2 数据传送指令
* 练习题3.3 当我们调用汇编器的时候，下面代码的每一行都会产生一个错误，解释哪里出了问题
```asm
movb $0xF,(%ebx)       //%ebx不能做地址寄存器
movl %rax,(%rsp)       //指令与操作数不匹配。 应当使用movq; 
movw (%rax),4(%rsp)    //操作数不能同时都是内存地址
movb %al,%sl           //没有%sl
movq %rax,$0x123       //立即数不可做结果存储
movl %eax,%rdx         //目的操作数过大，应为%edx
movb %si,8(%rbp)       //指令与操作数长度不匹配; %si是双字节，所以应当用movw 
```

* 零扩展数据传送
> 这些指令以寄存器或内存地址做为源，以寄存器做为目的地

```asm
movzbw
movzbl
movzbq
movzwl
movzwq
```

* 符号扩展数据传送
> 这些指令以寄存器或内存地址做为源，以寄存器做为目的地

```asm
movsbw
movsbl
movsbq
movswl
movswq
movslq
cltq           // 把%eax符号扩展到%rax
```
#### 3.4.3 数据传送示例
#### 3.4.4 压入和弹出栈数据
* 栈可以实现为一个数组，总是从数组的一端插入和删除元素。这一端被称为栈顶

* 栈只有一个出入口（栈顶），所以栈的原则是后进先出

* 栈指针%rsp总是指向栈顶（也就是说寄存器rsp中保存的值是栈顶的内存地址）

* 将四字数据压入栈中
```asm
pushq %rbp
// 它等价于下同这两条
subq $8,%rsp
movq %rbp,(%rsp)
```

* 将四字数据弹出栈
```asm
popq %rdx
// 它等价于下面两条命令
movq (%rsp),%rdx
addq $8,%rsp
```

### 3.5 算术和逻辑操作 
#### 3.5.1 加载有效地址
#### 3.5.2 一元和二元操作
* 练习题3.8 假设下面的值存放在指定的内存地址和寄存器中：
|地址|值|
|:-|:-|
|0x100|0xFF|
|0x108|0xAB|
|0x110|0x13|
|0x118|0x11|

|寄存器|值|
|:-|:-|
|%rax|0x100|
|%rcx|0x1|
|%rdx|0x3|

填写下表，给出下面指令的效果，说明将被更新的寄存器或内存位置，以及得到的值

|指令|目的|值|
|:-|:-|:-|
|addq %rcx,(%rax)|0x100|0xFF+1=0x100|
|subq %rdx,8(%rax)|0x108|0xAB-3=0xA8|
|imulq $16,(%rax,%rdx,8)|0x100+0x3*8=0x118|0x11*16=0x110| 注: 0x11*16相当于二进制数左移16位，16位二进制正好是16进制的一位
|incq 16(%rax)|0x100+0x10=0x110|0x13+0x1=0x14|
|decq %rcx|%rcx|0|
|subq %rdx,%rax|%rax|0x100-0x3=0xFD|

#### 3.5.3 移位操作
* 两个操作数，第一个是移位量，第二个是被移位的数
* 移位量可以是立即数，或%cl
* 因为64位长的数据值最多移位量超不过64，所以可以用一字节的%cl寄存器来编码移位量2^8 - 1 = 255位, 即只使用%cl的低m位决定, 2^m = 被移位数值的位数，
  %cl的高位会被忽略

#### 3.5.4 讨论 
##### 练习题3.11 常常可以看见以下形式的汇编代码行
```asm
xorq %rdx,%rdx
```
* 但是在产生这段汇编代码的C代码中，并没有出现EXCLUSIVE-OR操作

* A. 解释这条特殊的EXCLUSIVE-OR指令的效果，它实现了什么有用的操作。
> 因为x ^ x = 0;  所以可以利用异或操作来置0，即x=0;

* B. 更直接地表达这个操作的汇编代码是什么?
```asm
movq $0,%rdx
```
* C. 比较同样的一个操作的两种不同实现的编码字节长度
> 这个需要使用nm, as，加上汇编程序来具体查看
> 第一步，写如下程序，并将其保存成test.s文件
```asm
a: movq $0,%rdx
b: xorq %rdx,%rdx
c:
```
> 第二步，用汇编器as编译.s，生成test.o机器码
```shell
$: as -o test.o test.s
```

> 第三步，用nm查看test.o
```shell
$: nm test.o

0000000000000000 t a
0000000000000007 t b
000000000000000a t c

// 可以看到
// b - a = 7 - 0 = 7 字节, 对应movq这条指令
// a - 7 = 3 字节，对应xorq这条指令
```

#### 3.5.5 特殊的算术操作
* x86-64指令集对128位（16字节）数的操作提供有限支持
* %rdx, %rax组成一个128位的八字

### 3.6 控制
#### 3.6.1 条件码
* 条件码寄存器，它只有一个位长，用来描述最近的算术或逻辑操作结果
> 条件码寄存器可以用来构建程序的条件分支

|条件码寄存器|作用|功能描述|
|:-|:-|:-|
|CF|进位标志|最近的操作使最高位产生了进位|
|ZF|零标志|最近的操作得出的结果为0|
|SF|符号标志|最近的操作得到结果为负数|
|OF|溢出标志|最近的操作导致一个补码溢出－－正溢出或负溢出|

* 只改变条件码寄存器的两个指令CMP（比较）和TEST（测试）

* CMP指令根据两个操作数之差来设置条件码
```asm
cmpb
cmpw
cmpl
cmpq

CMP s1,s2 基于 s2 - s1
```

* TEST指令与AND指令唯一不同是它只改变条件码寄存器

#### 3.6.2 访问条件码
* 条件码怎么用？
> 用来设置字节为0或1

> 用来跳转

> 传送数据

```
// C语言代码
long cmpx(long a, long b)
{
	return a < b;
}
// 以下汇编实现C语言函数cmpx
cmpl %rsi,%rdi
setl %al        // 当cmpl操作结构为%rdi小于%rsi时，%al被设置成1，否则设置为0
movzbl %al,%eax // 如果C语言函数返回值类型为char的话，就没这句
```
* SET指令
> set指令根据条件码，将一个字节设置成0或1

|指令|效果|设置条件|同义名|
|:-|:-|:-|:-|
|sete	D|D <--- ZF|相等、0|setz|
|setne 	D|D <--- ~ZF|不等、非0|setnz|
|sets	D|D <--- SF|负数||
|setns	D|D <--- ~SF|非负数||
|setg	D|D <--- ~(SF^OF)&~ZF)|有符号的大于|setnle|
|setge	D|D <--- ~(SF^OF)|有符号的大于等于|setnl|
|setl	D|D <--- SF^OF|有符号小于|setnge|
|setle	D|D <---(SF^OF)|ZF|有符号的小于等于|setng|
|seta	D|D <--- ~CF&~ZF|无符号的大于|setnbe|
|setae	D|D <--- ~CF|无符号的大于等于|setnb|
|setb	D|D <--- CF|无符号小于|setnae|
|setbe	D|D <--- CF | ZF |无符号小于等于|setna|

* 所有的算术和逻辑操作都设置条件码

* 无符号数只使用CF和ZF两个寄存器进行比较

* 有符号数需要使用OF,SF,ZF三个寄存器进行判断>,<,=

* 练习题3.13
```
int comp(data_t a, data_t b)
{
	return a COMP b;
}
// 根据下面汇编代码来判断上面C语言函数中变量a,b的数据类型
A.	cmpl	%esi,%edi   	// 由cmpl中的l可知是32位长数据类型
	setl	%al		// 由setl可知是有符号类型
				// 所以A中a,b数据类型一定是int
B.	cmpw	%si,%di		// cmpw中的w，可知是16bit
	setge	%al		// setge说明是有符号数
				// B中的a,b数据类型为short
C.	cmpb	%sil,%dil       // cmpb---->8bit
	setbe	%al		// setbe--->无符号
				// C中a,b类型为unsigned char
D.	cmpq	%rsi,%rdi	// cmpq---->64bit
	setne	%al		// setne--->有无符号都可
				// D的a,b数据类型为long, unsigned long
```

#### 3.6.3 跳转指令









