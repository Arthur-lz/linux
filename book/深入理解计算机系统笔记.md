## 体系

### 机器语言01、汇编语言、C语言

#### 扫盲rsp, edi, eax
* 这些是CPU中寄存器的名字
##### 指令寄存器
* 它们主要用于访问堆栈内的存储单元，并且规定：

（1）BP为基指针(BasePointer)寄存器，用它可直接存取堆栈中的数据；
（2）SP为堆栈指针(StackPointer)寄存器，用它只可访问栈顶。
* 寄存器RBP、RSP和EBP、ESP和BP、SP称分别为64位、32位、16位指针寄存器(PointerRegister)

##### 变址寄存器
* 它们可作一般的存储器指针使用。在字符串操作指令的执行过程中，对它们有特定的要求，而且还具有特殊的功能。
* 寄存器RSI、RDI和ESI、EDI和SI、DI分别称为64位、32位、16位变址寄存器(Index Register)。

##### 数据寄存器
* 主要用来保存操作数和运算结果等信息，从而节省读取操作数所需占用总线和访问存储器的时间。
* RAX、RBX、RCX、RDX和EAX、EBX、ECX、EDX以及AX、BX、CX、DX分别称为64位、32位、16位数据寄存器(通用寄存器)。

##### 寄存器基本概念 
* 在中央处理器的控制部件中，包含的寄存器有指令寄存器(IR)和程序计数器(PC)。
* 在中央处理器的算术及逻辑部件中，包含的寄存器有累加器(ACC)。

#### 汇编
* 汇编的编译解释与具体的体系结构相关，如，在x86平台上，CPU是Intel的，那么需要用到Intel开发人员手册，里面有关于汇编助记符的定义，
  如subq, addq, movl等

> 为什么与体系结构相关? 首先要明白，汇编器的作用是将汇编程序翻译成机器码，机器码与具体的CPU相关，只有正确的芯片才可以识别出。

### DMA
   外设（如磁盘）与主存建立映射，CPU告诉DMA需要传多少数据，只有当将所需数据全部由外设传递到主存后才通知CPU，而不是每读一部分数据（如一个字节）就通知一下CPU							 

### ulimit -s 查看linux进程默认栈大小, 结果的单位是kB;
   也可以用ulimit -a查询所有资源限制，结果中包含了单位   

### 使用int32_t等数据类型宏定义来支持程序的可移植性   
    这样就不会因为从32位机切到64位机时出现数据类型对应到不同的位长度问题

## 第1章
### 1.1 信息就是位 + 上下文
* 系统中所有的信息都是由一串比特表示的。区分不同数据对象的唯一方法是我们读到这些数据时的上下文。    
* C语言是设计用来实现Unix操作系统的.

### 1.2 程序被其他程序翻译成不同格式
* 编译系统
hello.c->预处理->hello.i(修改了的源程序，还是文本) 
	     ->编译器(cc)->hello.s（汇编程序，还是文本）
	         ->汇编器(as)->hello.o （可重定位的目标程序，已经变成二进制文件）
		     ->链接器(ld)->hello.out（可执行的目标程序，二进制文件）

* 预处理，根据源文件中以字符#开头的命令修改原始的C程序。

* 编译器，将.i文件翻译成文件文件.s，它是一个包含汇编语言的程序。

* 汇编器，将.s文件翻译成机器语言指令，并把结果保存在二进制.o文件中。

* 链接器，将源程序中依赖的目标文件合并到可执行目标文件。

### 1.3 了解编译系统如何工作是大有益处的
### 1.4 处理器读并解释存储在内存中的指令
#### 1.4.1 系统的硬件组成 
#### 1.4.2 运行hello程序
* 见目录deepincomputerlab/code/intro/目录中的几个图片说明了hello从终端输入到运行结束全过程.
### 1.5 高速缓存至关重要
* 解决CPU与主存之间速度差过大（100倍左右）而引入高缓。
### 1.6 存储设备形成层次结构
* 见目录deepincomputerlab中的png
### 1.7 操作系统管理硬件
* 操作系统有两个功能
> 防止硬件被失控的应用程序滥用

> 向应用程序提供简单一致的机制来控制复杂又不相同的低层硬件设备

* 操作系统通过三个抽象来实现上面的两个功能，即虚拟内存、进程、文件
> 文件是对I/O设备的抽象

> 虚拟内存是对主存和磁盘I/O设备的抽象

> 进程是对CPU、主存、I/O设备的抽象

#### 1.7.1 进程
* 在一个系统上可以同时运行多个进程, 
* 并发运行，指一个进程的指令和另一个进程的指令是交错执行的, 这是通过处理器在进程间切换实现的, 这种机制称为上下文切换。
* 操作系统会保存进程运行所需的所有状态信息, 这种状态就是上下文，包括：PC(程序计数器)、寄存器中的值，主存的内容等。
* 在任何一个时刻，单核处理器只能运行一个进程的代码
* 当操作系统决定把控制权从当前进程转移到某个新进程时，就会进行上下文切换。即，保存当前进程上下文，恢复新进程上下文，然后将控制权转移到新进程，新进程就会从它上次停止的地方开始执行。

* 内核不是一个独立的进程，它是什么呢？内核是操作系统管理全部进程所需要的代码和数据结构的集合。

#### 1.7.2 线程
* 线程运行在进程上下文
* 线程间共享数据更方便简单
* 多线程可提高性能，当然你的应用程序必须要使用多线程才可以

#### 1.7.3 虚拟内存 
* 它提供了一种假象，即，每个进程都是独占的使用内存
* 每个进程看到的内存都是相同的, 称为虚拟地址空间

#### 1.7.4 文件 
* 文件就是字节序列

### 1.8 系统之间利用网络来通信 
### 1.9 重要主题
#### 1.9.1 Amdahl 定律(阿姆达尔定律)
* 用于分析计算系统性能的定律
* S = Told / Tnew
* S = 1/((1 - a) + a/k)

#### 1.9.2 并发和并行
* 线程级并发
> 多核处理器结构，L1，L2在每一个核的内部，L3在核的外部CPU内部是所有核共享的一块高速缓存

> 多核处理器可以从两方面提高系统性能，1是减少使用并发，2是提高应用程序速度（当然应用程序必须以多线程方式编写，这些线程可以并行执行）

> 线程级并发我的理解与进程并发原理相同，比如，一个线程必须要等到数据加载到L1高速缓存中，那么此时CPU就可以去执行另外一个线程。

* 指令级并行
> 指令流水线, 将一条指令拆分成不同的步骤，将处理器的硬件组织成一系统阶段，每个阶段执行一个步骤，这些阶段并行的执行，用来处理不同指令的不同部分。

* 单指令多数据并行(SIMD) 

#### 1.9.3 计算机系统中抽象的重要性 
* 指令集架构是对实际处理器硬件的抽象，这样机器代码表现得好像运行在一个一次只执行一条指令的处理器上一样。

### 1.10 小结
* 计算机系统是硬件和系统软件组成的，它们共同协作让应用程序可以运行。

## 第二章 信息的表示和处理 
* 学习目标？
> 数据类型是如何表示的?

> 硬件是如何实现的？如，CPU是如何实现的？这些硬件是如何被用来执行指令的？

> 程序是如何表示的? 如何执行的?

* 二进制数－－－数字革命的基础
> 在构造存储和处理信息的机器时，二进制工作得更好。二进制可以很容易被表示，如：电平的高低、磁的两极、打孔机的孔。

* 程序员需要对计算机运算与人类熟悉的整数和实数运算之间的关系有清晰的理解

* C的几个不同版本 
> GNU 89, GCC命令行无配置选项时，或-std=gnu89时，使用GNU 89版本的C语言进行编译

> ANSI C, ISO C90, GCC命令行选项使用-ansi, 或 -std=c89时，使用

> ISO C99, GCC命令行使用选项 -std=c99

> ISO C11, GCC命令行使用选项 -std=c11

### 2.1 信息存储
* C语言中，一个指针的值，无论它指向什么数据结构（整数、结构或某个其他程序对象），它都是某个存储块第一个字节的虚拟地址。

* 大概理解了，为什么为有虚拟地址空间这个概念，因为要统一程序自身的差异，这样编译器和运行时系统才可以知道如何用内存来存放不同的程序对象。

* C编译器维护指针类型，但它编译出来的机器指令中没有数据类型相关信息。其实是这样，数据类型是告诉程序需要从指针所指的地址处读多长的数据，
  如int *p; int表示指针p所指向的地址处有四个字节的数据是有效的，在p++时，指针p会移动四个字节；而前面说的四个字节是由数据类型int而得到的。

#### 2.1.1 十六进制表示法  
* 10进制数转16进进制方法
> 举例说明：10进制数188转成16进制
  188 = 11 * 16 + 12   ---> C
  11 = 0 * 16 + 11     ---> B
  所以，十进制数188对应的十六进制数为0xBC
> 这里需要注意的是第一，下次等号左面的数是上一个等式中乘16的那个数
                  第二，最后一个等式的余数是十六进制数的最高位

* 16进制转10进制方法
> 举例说明: 16进制数0x3C转换成10进制数x
  x = 3 * (16 * 1) + 12 * (16 * 0) = 60
                |               |
            16的一次方       16的0次方
                
* 16进制转2进制方法
> 举例说明: 16进制数0x12转换成2进制数x
  x = 0001 0010
       |    |
       1    2

#### 2.1.2 字数据大小
* 每台计算机都有一个字长，指明指针数据的标称大小。虚拟地址是以这样一个字来编码的。

|C声明||字节数|字节数|
|:-|:-|:-|:-|
|有符号|无符号|32位|64位|
|char|unsigned char|1|1|
|short|unsigned short|2|2|
|int|unsigned|4|4|
|long|unsigned long|4|8|
|int32_t|uint32_t|4|4|
|int64_t|uint64_t|8|8|
|char*||4|8|
|float||4|4|
|double||8|8|

> int32_t, int64_t是ISO C99引入的，这种类型长度固定，不会因为编译器和机器设置而变化。
 
* 下面这几个不同的声明表达的意思相同
> unsigned long

> unsigned long int

> long unsigned

> long unsigned int

即关键字顺序不唯一哈

* C语言标准对不同数据类型的数字范围设置了下界，但是没有设置上界
>  没上界，在程序从32位迁移到64位机时可能会出现问题

#### 2.1.3 寻址和字节顺序
* 多字节对象，必须明确两点：
> 对象地址

> 在内存中如何排列这些字节

* 在几乎所有机器上，多字节对象都被存储为连续的字节序列，对象的地址是字节序列中最小的地址。
> 举例说明, int x; 

> 这里假设变量x的地址为0x100，也就是说&x = 0x100，那x的四个字节将被存储在内存的0x100, 0x101, 0x102, 0x103四个地址上。

* 大小端序
> 机器选择将最低有效字节放在最前面－－－小端序

> 机器选择将最高有效字节放在最前面－－－大端序

> 大多数Intel兼容的机器使用小端序

> 较新的微处理器支持双端模式，即可以配置成大端或小端，但是在选择了特定的操作系统之后，那么字节序也同时固定了，如ARM本身支持双端模式，
  但常用的Andoid或iOS操作系统只能使用小端字节序。

* Intel处理器机器代码文本（其由反汇编器生成）举例：
```as
4004d3: 01 05 43 0b 20 00	add	%eax,0x200b43(%rip)
```
> 首先Intel处理器字节序是小端序

> 其次十六进制字节串01 05 43 0b 20 00是一条指令的字节级表示, 它与add	%eax,0x200b43(%rip)等价

> 取出这条指令字节序列中后四个字节43 0b 20 00，将其反序排列00 20 0b 43，得到值0x00200b43，即0x200b43，这与汇编指令表示中的数值相等。 

* 字节序的另一个应用：强制类型转换或联合，它允许以另外一种数据类型T来引用数据对象，而T与数据对象创建时使用的数据类型t不同。

* man ascii, 查看ascii字符码表

* 看下面这道题
``` c
int x = 0x87654321;
unsigned char* c1 = &x;  
unsigned short * s2 = &x;
// c1, s2的大小端值是什么？
/* 大端
   地址：1   2   3   4
     值：87  65  43  21

   小端
   地址：1   2   3   4
     值：21  43  65  87

     c1大端值等于87;
     c1小端值等于21;

     s2大端值等于87 65;
     s2小端值等于21 43;

     这里需要明确变量的地址是怎么定义的，指针c1, s2的地址是其所指向字节序列中第一个字节的地址，即最左面的那个字节对应的地址。
     以变量x来说明，大端字节序时，c1的地址就是87的地址，s2的地址也是87；小端序时，c1的地址是21的地址，s2的地址与c1相同，都是指向&x;
   
   */

```
#### 2.1.4 表示字符串
* 在使用ASCII码作为字符码的任何系统上，其值与字节序无关。即，在大端或小端机器上输出任意字符串（如"12345"）得到的结果都是相同的（31 32 33 34 35）
> 因此，文本字符串类型的数据比二进制数据在平台移植上更占优势。

* strlen，它不计算字符串中终止的空字符null，所以strlen("12345")=5，而实际上"12345"的长度是6，因为还有一个\0

* 二进制代码很少能在不同机器和操作系统组合之间移植
> 从机器的角来看，程序仅仅是字节序列。机器没有关于原始源程序的任何信息。

* UTF-8是变长编码的，所有ASCII字节序列用ASCII码表示和用UTF-8码表示是一样的 

* Unicode是定长4字节编码的

#### 2.1.6 布尔代数简介
* TRUE, FALSE------> 1, 0

* 与运算&, 或运算|, 异或运算^
> 1 & 1 = 1;  1 & 0 = 0;  0 & 0 = 0;

> 1 | 1 = 1;  1 | 0 = 1;  0 | 0 = 0;

> 1 ^ 1 = 0; 1 ^ 0 = 1; 0 ^ 0 = 0;

#### 2.1.7 C语言中的位级运算
* 位级运算常用于实现掩码运算, 表示从一个字中选出的位的集合
> 举例说明，掩码0xFF表示取一个字的低8位，如x&0xFF, x = 0x89ABCDEF, 那么x & 0xFF = 0xEF

* ~0将生成一个全1的掩码，对于32位机器可以写成0xFFFF FFFF，但这样的代码是不能移植的

* 练习题2.12对于下面的值，写出变量x的C语言表达式。你的代码应该对任何字长w>=8都能工作。我们给出了当x=0x87654321以及w=32时表达式求值的结果，
仅供参考。
>A. x的最低有效字节，其他位均设置为0。 [0x00000021]。
```c
// 作答如下
  x = x & 0xFF; // 因为值以十六进制表示时两个十六进制数表示一字节，所以掩码为0xFF
```

>B. 除了x的最低有效字节外，其他的位都取补，最低有效字节保持不变。[0x789ABC21]。
```c
// 作答如下
x = x^~0xFF;

```

>C. x的最低有效字节设置成全1，其他字节都保持不变。[0x876543FF]
```c
// 作答如下
x = x|0xFF;

```
* 异或运算x^y = (x&~y)|(~x&y)

#### 2.1.8 C语言中的逻辑运算	
* 逻辑与运算&&
* 逻辑或||
* 逻辑非!
> 不要将逻辑运算与位运算混淆

* 练习题2.15只使用位级和逻辑运算，编写一个C语言表达式，它等价于 x==y。
```
答：
当且仅当x的每一位和y相应的每一位匹配时，x^y等于0。然后我们用!来判断一个字是否包含任何非0位。

```
#### 2.1.9 C语言中的移位运算
* 左移<<，如0x87654321 << 4 = 0x76543210, 这就表示把数据向左移动4位，把原值最左面4位删除，同时把原值最右面4位用0补上。
* 右移>>，机器一般支持两种右移，逻辑右移和算术右移。
> 几乎所有的编译器和机器组合都对有符号数使用算术右移，而对无符号数采用逻辑右移。

* 位移量如果超出了数值实际长度，则对位移量取模做为位移量，举例如下 
```c
int v1 = 0xFEDCBA98 << 32;
int v2 = 0xFEDCBA98 >> 36;
unsigned v3 = 0xFEDCBA98u >> 40;

/* v1 左移32位，而其是int 类型，长度为4字节，正好32位，那么它实际上移动的位数是0，即32 mod 32 = 0;
   v2 右移36位，同要是int类型，数据长度为32位，所以36 mod 32 = 4, 所以其实际移动的位移量是4;
   v3 右移40位，是无符号的int类型，数据长度为32位，所以 40 mod 32 = 8, 所以其实际移动的位移量是8；
 */
```

* 在C语言中，加法、减法的优先级比移位运算高
```c
  1<<2+3<<4 = 1 << (2 + 3) << 4 = 512 // 2^9
```

### 2.2 整数表示
#### 2.2.1 整型数据类型
#### 2.2.2 无符号数的编码
#### 2.2.3 补码编码
* 有符号数最常见的表示方式是补码 
* 补码的计算举例
```
  二进制值0001 = -0 * 2^3 + 0 * 2^2 + 0 * 2^1 + 0 * 2^0 = 0 + 0 + 0 + 1 = 1;
  二进制值0101 = -0 * 2^3 + 1 * 2^2 + 0 * 2^1 + 1 * 2^0 = 0 + 4 + 0 + 1 = 5;
  二进制值1011 = -1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 * 2^0 = -8 + 0 + 2 + 1 = -5;
  二进制值1111 = -1 * 2^3 + 1 * 2^2 + 1 * 2^1 + 1 * 2^0 = -8 + 4 + 2 + 1 = -1;

  0x2e0对应二进制值为 0010 1110 0000 = 1 * 2^9 + 1 * 2^7 + 1 * 2^6 + 1 * 2^5 = 512 + 128 + 64 + 32 = 736; 
  -0x58对应二进制值为 -(0101 1000) = -(1 * 2^6 + 1 * 2^4 + 1 * 2^3) = -(64 + 16 + 8) = -88;
  -0x30对应二进制值为 -(0011 0000) = -(1 * 2^5 + 1 * 2^4) = -(32 + 16) = -48;
  上面的值取处反汇编器生成的ASCII码形式的程序

  4004d0: 48 81 ec e0 20 00 00	sub	$0x2e0,%rsp
  4004d7: 48 8b 44 24 a8	mov 	-0x58(%rsp),%rax
  4004ec: 48 03 47 28		add	0x28(%rdi),%rax
  4004e0: 48 89 44 24 d0	mov	%rax,-0x30(%rsp)

```
#### 2.2.4 有符号数和无符号数之间的转换









