## linux内核文件的区别(vmlinux、zImage、bzImage、uImage、vmlinuz、initrd )
|内核|说明|
|:-|:-|
|vmlinux|  编译出来的最原始的内核文件，未压缩。
|zImage |  是vmlinux经过gzip压缩后的文件。
|bzImage| bz表示“big zImage”，不是用bzip2压缩的。两者的不同之处在于，zImage解压缩内核到低端内存(第一个640K)，bzImage解压缩内核到高端内存(1M以上)。如果内核比较小，那么采用zImage或bzImage都行，如果比较大应该用bzImage。
|uImage|   U-boot专用的映像文件，它是在zImage之前加上一个长度为0x40的tag。
|vmlinuz|  是bzImage/zImage文件的拷贝或指向bzImage/zImage的链接。
|initrd |  是“initial ramdisk”的简写。一般被用来临时的引导硬件到实际内核vmlinuz能够接管并继续引导的状态。

## 内存
### MMU
* 操作数据的最小单位是页
* CPU不同（即体系结构不同），CPU支持的页大小也不同，有4KB, 8KB, 16KB等，Intel的至强处理器可以支持2MB和1GB的大页
> 4KB的小页效率低，会浪费过多的page_struct结构实例来管理它

* kernel默认页大小是4KB 

#### TLB
* TLB位于MMU内部，它是一块高速缓存，用来保存页表转换结果，即CPU判断某个虚拟地址是否有效，会首先查TLB，如果TLB中有此虚拟地址，则直接从TLB里找到虚拟地址对应的物理地址来使用。否则，就称TLB未命中，此时MMU会负责去查找页面表，找到后将其存到TLB，同时给CPU使用。

#### 物理内存到虚拟内存
* mm_struct里的PGD成员保存了一级页表基址
* 以ARM体系结构的CPU为例来说明，虚拟地址到物理地址转换流程
> ARM是二级页表结构，虚拟地址位宽为32位

> 31至20位（高12位）用于存一级页表索引, 一级页表项中保存着二级页表基址, 一级页表总共有4096个页表项
  TTBRx寄存器中保存一级页表基地址

> 19至12位（中间的8位）用于存二级页表索引，二级页表项中保存着物理页面基址，二级页表总共有256个页表项

> 11至0位(低12位)用于在物理页面中定位到具体是哪个字节(因为这12位正好可以寻址4096，即一页大小)

* 进程内部由许多VMA结构（代码段VAM，数据段VMA，堆VMA，malloc的VMA, mmap的VMA等）组成，它代表进程的虚拟地址，其对应的物理地址，在实际需要时，通过CPU中的MMU硬件来实现虚拟与物理地址一一对应。

> VMA是基于分页机制来实现的，进程所占用的内存使用以页为单位的虚拟内存来管理，这样当系统内存不足/进程上下文切换时，系统可以以页为单位只回收进程所占用的部分内存，这比分段机制换出整个进程来说粒度更细效率更高。

* 内核中的内存地址？
> 内核空间虚拟地址／逻辑地址
  
### 内存的申请、释放
#### 伙伴系统
##### alloc_pages
* 申请的物理页面是连续的，页面数量是2的order次方，申请成功返回第一页面的page结构指针

##### \__get_free_pages
* 申请成功返回的是第一个页面的逻辑地址（即内核虚拟地址）

##### 页面回收
* 将回收的页面进行合并组成大的连续的内存，合并内存有以下三个原则，
> 1、必须是由同一个大块内存分割而来

> 2、两个内存块必须是物理地址连续

> 3、两个内存块大小必须相同

* 内存碎片与内存规整
  内存规整就是利用移动页面的位置让空闲页面连成一片。

> 相关概念：
  迁移类型, 按照迁移类型不同，可以分为“不可迁移类型页面”、“可迁移类型页面”、“可回收的页面”这三类
  页块大小是页面分配器最大的分配大小，即2的MAX_ORDER-1次方，通常是4MB
  free_area[MAX_ORDER], 其每一个成员中有三种不同迁移类型的链表用来存储对应的页面, 每一种类型有2的order次方个页块 

#### slab
##### kmalloc
* 按字节申请，申请成功返回内存逻辑地址

#### numa（与uma相对应）
* 非一致内存
* 用node结点来管理每一个CPU上的内存，每一个node上分为多个不同的zone（DMA, DMA32, normal）
